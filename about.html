<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Networks Laboratory</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <span>Computer Networks Lab</span>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">Home</a>
                </li>
                <li class="nav-item">
                    <a href="about.html" class="nav-link active">About</a>
                </li>
                <li class="nav-item">
                    <a href="recordings.html" class="nav-link">Recordings</a>
                </li>
                <li class="nav-item">
                    <a href="notes.html" class="nav-link">Notes</a>
                </li>
            </ul>
            <button id="theme-toggle" class="theme-toggle">
                <span class="theme-icon">üåô</span>
            </button>
            <div class="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <header class="main-header">
        <h1 id="main-title" class="fade-in">About CN Laboratory</h1>
        <p class="header-subtitle">Detailed explanations of all computer networks concepts</p>
    </header>

    <main class="about-main">
        <div class="about-container">
            <!-- Week 1: Data Link Layer Framing Methods -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 1: Data Link Layer Framing Methods</h2>
                    <div class="week-badge">3 Programs</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>The Data Link Layer is responsible for node-to-node delivery of frames within a local network segment. Framing is one of its most critical functions, providing a way to delineate where one frame begins and another ends in the continuous stream of bits. Without proper framing mechanisms, receiving stations cannot determine frame boundaries, leading to data corruption and communication failures.</p>
                        
                        <p>This week's laboratory exercises explore three fundamental framing techniques that have shaped modern networking protocols. Each method represents a different approach to solving the frame delimitation problem, with unique advantages and challenges that reflect the evolution of networking technology.</p>
                        
                        <div class="technical-details">
                            <h4>Technical Foundation</h4>
                            <p><strong>Frame Structure:</strong> A typical frame consists of a header (containing control information), payload (actual data), and trailer (error detection/correction). The challenge lies in reliably identifying these boundaries in a stream of bits.</p>
                            
                            <p><strong>Synchronization:</strong> Frame synchronization ensures that the receiver can correctly interpret the incoming bit stream. Poor synchronization can lead to frame slip, where the receiver loses track of frame boundaries entirely.</p>
                            
                            <p><strong>Error Propagation:</strong> Different framing methods have varying resilience to errors. Some methods can confine errors to single frames, while others may cause multiple frame losses from a single bit error.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Character Counting</h4>
                                <span class="difficulty-badge easy">Basic</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/character counting.png" alt="Character Counting Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Purpose:</strong> Uses a count field in the frame header to specify the exact number of characters (bytes) in the frame's data field.</p>
                                
                                <p><strong>Mechanism:</strong> The receiver reads the count field and then processes exactly that many characters as the frame's payload. Once the count is reached, the next character is assumed to be the start of a new frame.</p>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Simple to implement and understand</li>
                                    <li>Minimal protocol overhead</li>
                                    <li>No special character restrictions on data</li>
                                    <li>Efficient for fixed-length protocols</li>
                                </ul>
                                
                                <p><strong>Disadvantages:</strong></p>
                                <ul>
                                    <li>Catastrophic failure if count field is corrupted</li>
                                    <li>No frame boundary markers for error recovery</li>
                                    <li>Difficult to resynchronize after errors</li>
                                    <li>Single bit error can cause loss of multiple frames</li>
                                </ul>
                                
                                <p><strong>Real-world Applications:</strong> Early IBM protocols, some embedded systems with reliable channels, educational demonstrations of framing concepts.</p>
                            </div>
                        </div>

                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Character Stuffing</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/characterstuffing.png" alt="Character Stuffing Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Purpose:</strong> Uses special delimiter characters (typically STX - Start of Text, ETX - End of Text) to mark frame boundaries, with escape mechanisms to handle these characters in data.</p>
                                
                                <p><strong>Mechanism:</strong> Frames begin with STX and end with ETX. If STX or ETX appear in the data payload, they are preceded by an escape character (ESC). If ESC itself appears in data, it is escaped by another ESC.</p>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Clear frame boundary identification</li>
                                    <li>Better error recovery than character counting</li>
                                    <li>Can resynchronize on next frame delimiter</li>
                                    <li>Widely understood and implemented</li>
                                    <li>Suitable for text-based protocols</li>
                                </ul>
                                
                                <p><strong>Disadvantages:</strong></p>
                                <ul>
                                    <li>Variable overhead depending on data content</li>
                                    <li>Complex escape sequence handling</li>
                                    <li>Inefficient for binary data with many special characters</li>
                                    <li>Requires character-oriented processing</li>
                                </ul>
                                
                                <p><strong>Real-world Applications:</strong> Legacy terminal protocols (VT100), early email systems (SMTP), text-based network protocols, serial communication systems.</p>
                                
                                <p><strong>Escape Sequence Example:</strong> Data "Hello$World" becomes "$Hello/$World$" where $ is flag and / is escape character.</p>
                            </div>
                        </div>

                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Bit Stuffing</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/BitsStuffing.png" alt="Bit Stuffing Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Purpose:</strong> Uses unique bit patterns as frame delimiters and automatically stuffs bits to prevent accidental flag patterns in data, ensuring complete data transparency.</p>
                                
                                <p><strong>Mechanism:</strong> HDLC uses the flag sequence 01111110. Whenever five consecutive 1s appear in the data, a 0 is automatically stuffed after them. The receiver performs the reverse operation, removing stuffed bits.</p>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Complete data transparency - any bit pattern can be transmitted</li>
                                    <li>Efficient bandwidth utilization</li>
                                    <li>Excellent error recovery capabilities</li>
                                    <li>No dependency on character boundaries</li>
                                    <li>Widely adopted in modern protocols</li>
                                    <li>Allows for priority and control frames</li>
                                </ul>
                                
                                <p><strong>Disadvantages:</strong></p>
                                <ul>
                                    <li>Complex bit-level processing required</li>
                                    <li>Variable frame length due to stuffing</li>
                                    <li>Requires sophisticated hardware/software</li>
                                    <li>Slight overhead for data with many 1s</li>
                                </ul>
                                
                                <p><strong>Real-world Applications:</strong> HDLC (High-Level Data Link Control), PPP (Point-to-Point Protocol), Frame Relay, ISDN protocols, modern Ethernet variants.</p>
                                
                                <p><strong>Technical Details:</strong> The stuffing algorithm maintains a counter of consecutive 1s. When it reaches 5, a 0 is inserted regardless of the next bit. This ensures the flag pattern 01111110 never appears in data.</p>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Theoretical Understanding:</strong> Comprehend the fundamental problem of frame delimitation and why it's critical in data communication</li>
                            <li><strong>Comparative Analysis:</strong> Evaluate the trade-offs between different framing methods in terms of efficiency, complexity, and error resilience</li>
                            <li><strong>Implementation Skills:</strong> Develop practical C programming skills for implementing framing algorithms and handling edge cases</li>
                            <li><strong>Error Analysis:</strong> Analyze failure modes and understand how different framing methods handle and recover from transmission errors</li>
                            <li><strong>Protocol Design:</strong> Appreciate the design decisions that led to modern framing protocols and their evolution</li>
                            <li><strong>Performance Evaluation:</strong> Measure and compare the efficiency of different framing methods under various data patterns</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Relevance</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üåê Internet Protocols</h4>
                                <p>Modern internet protocols like PPP and Ethernet use sophisticated framing mechanisms derived from these fundamental concepts. Understanding these basics is essential for network protocol development.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì° Wireless Communications</h4>
                                <p>Cellular networks, WiFi, and Bluetooth all employ advanced framing techniques that build upon these foundational methods, especially for managing error-prone wireless channels.</p>
                            </div>
                            <div class="application-item">
                                <h4>üè≠ Industrial Systems</h4>
                                <p>Manufacturing and control systems use robust framing protocols for real-time communication between sensors, controllers, and monitoring systems.</p>
                            </div>
                            <div class="application-item">
                                <h4>üîí Security Protocols</h4>
                                <p>Secure communication protocols must ensure frame integrity not just for functionality but also to prevent security vulnerabilities through frame manipulation attacks.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 2: CRC Code Implementation -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 2: CRC Code Implementation</h2>
                    <div class="week-badge">Error Detection</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Cyclic Redundancy Check (CRC) represents one of the most mathematically elegant and practically effective error detection mechanisms in computer networks. Based on polynomial arithmetic over finite fields, CRC provides superior error detection capabilities compared to simple checksums while maintaining computational efficiency.</p>
                        
                        <p>CRC codes can detect all single-bit errors, all double-bit errors, any odd number of errors, and all burst errors of length less than or equal to the degree of the generator polynomial. This makes them ideal for detecting the types of errors commonly encountered in digital communication systems.</p>
                        
                        <div class="technical-details">
                            <h4>Mathematical Foundation</h4>
                            <p><strong>Polynomial Representation:</strong> Data is treated as coefficients of a polynomial in GF(2), where arithmetic is performed modulo 2. For example, the byte 10110001 represents the polynomial x‚Å∑ + x‚Åµ + x‚Å¥ + 1.</p>
                            
                            <p><strong>Generator Polynomial:</strong> A carefully chosen polynomial G(x) that determines the error detection properties. Common examples include CRC-16 (x¬π‚Å∂ + x¬π‚Åµ + x¬≤ + 1) and CRC-32 (x¬≥¬≤ + x¬≤‚Å∂ + x¬≤¬≥ + x¬≤¬≤ + x¬π‚Å∂ + x¬π¬≤ + x¬π¬π + x¬π‚Å∞ + x‚Å∏ + x‚Å∑ + x‚Åµ + x‚Å¥ + x¬≤ + x + 1).</p>
                            
                            <p><strong>Division Process:</strong> The data polynomial D(x) is multiplied by x^r (where r is the degree of G(x)) and then divided by G(x). The remainder becomes the CRC checksum.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>CRC Algorithm Implementation</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/CRC.png" alt="CRC Algorithm Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Purpose:</strong> Generates redundant check bits using polynomial long division to detect transmission errors with very high probability.</p>
                                
                                <p><strong>Algorithm Steps:</strong></p>
                                <ol>
                                    <li>Append r zero bits to the data (where r is degree of generator polynomial)</li>
                                    <li>Divide the extended data by the generator polynomial using modulo-2 arithmetic</li>
                                    <li>The remainder (r bits) becomes the CRC checksum</li>
                                    <li>Transmit original data followed by the CRC checksum</li>
                                    <li>Receiver performs the same division - zero remainder indicates no errors</li>
                                </ol>
                                
                                <p><strong>Error Detection Capabilities:</strong></p>
                                <ul>
                                    <li><strong>Single-bit errors:</strong> 100% detection rate</li>
                                    <li><strong>Double-bit errors:</strong> 100% detection rate</li>
                                    <li><strong>Odd number of errors:</strong> 100% detection (if G(x) has (x+1) as factor)</li>
                                    <li><strong>Burst errors:</strong> All bursts ‚â§ r bits, 99.97% for longer bursts</li>
                                    <li><strong>Random errors:</strong> (1 - 2^(-r)) probability of detection</li>
                                </ul>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Very high error detection probability</li>
                                    <li>Mathematically proven performance guarantees</li>
                                    <li>Efficient hardware and software implementations</li>
                                    <li>Standardized polynomials with known properties</li>
                                    <li>Excellent burst error detection</li>
                                    <li>No false positives for detected error patterns</li>
                                </ul>
                                
                                <p><strong>Disadvantages:</strong></p>
                                <ul>
                                    <li>More computationally complex than simple checksums</li>
                                    <li>Cannot correct errors, only detect them</li>
                                    <li>Requires understanding of polynomial arithmetic</li>
                                    <li>Fixed overhead regardless of data size</li>
                                </ul>
                                
                                <p><strong>Common Polynomials:</strong></p>
                                <ul>
                                    <li><strong>CRC-8:</strong> x‚Å∏ + x¬≤ + x + 1 (used in 1-Wire, SMBus)</li>
                                    <li><strong>CRC-16-IBM:</strong> x¬π‚Å∂ + x¬π‚Åµ + x¬≤ + 1 (used in USB, Modbus)</li>
                                    <li><strong>CRC-16-CCITT:</strong> x¬π‚Å∂ + x¬π¬≤ + x‚Åµ + 1 (used in HDLC, X.25)</li>
                                    <li><strong>CRC-32:</strong> IEEE 802.3 standard (used in Ethernet, PNG, ZIP)</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Practical Implementation Techniques</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Table-Driven CRC:</strong> Pre-compute remainders for all possible byte values to speed up calculation. This reduces the number of XOR operations from 8 per byte to 1 per byte.</p>
                                
                                <p><strong>Hardware Implementation:</strong> Linear Feedback Shift Registers (LFSR) can compute CRC in real-time as data streams through the circuit, enabling wire-speed processing in network equipment.</p>
                                
                                <p><strong>Software Optimizations:</strong></p>
                                <ul>
                                    <li>Bit-reflected algorithms for little-endian processors</li>
                                    <li>Slice-by-8 algorithms processing multiple bytes simultaneously</li>
                                    <li>SIMD instructions for parallel processing</li>
                                    <li>Specialized CPU instructions (e.g., Intel CRC32 instruction)</li>
                                </ul>
                                
                                <p><strong>Performance Considerations:</strong></p>
                                <ul>
                                    <li>Table lookup: ~1 cycle per byte</li>
                                    <li>Bit-by-bit: ~8 cycles per byte</li>
                                    <li>Hardware LFSR: 1 cycle per bit stream</li>
                                    <li>CPU instruction: 1 cycle per 32-bit word</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Mathematical Understanding:</strong> Master polynomial arithmetic in GF(2) and understand how it applies to error detection</li>
                            <li><strong>Algorithm Implementation:</strong> Develop efficient C implementations of CRC algorithms including both bit-by-bit and table-driven approaches</li>
                            <li><strong>Error Analysis:</strong> Quantify and verify the error detection capabilities of different CRC polynomials through theoretical analysis and practical testing</li>
                            <li><strong>Performance Optimization:</strong> Compare and implement various CRC optimization techniques for different computational constraints</li>
                            <li><strong>Protocol Integration:</strong> Understand how CRC is integrated into real network protocols and data formats</li>
                            <li><strong>Polynomial Selection:</strong> Learn the criteria for choosing appropriate generator polynomials for specific applications</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Protocol Usage</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üåê Network Protocols</h4>
                                <p>Ethernet frames use CRC-32 for frame check sequence. WiFi (802.11) and many other IEEE standards rely on CRC for maintaining data integrity in wireless environments with high error rates.</p>
                            </div>
                            <div class="application-item">
                                <h4>üíæ Storage Systems</h4>
                                <p>Hard drives, SSDs, and RAID systems use CRC codes to detect data corruption. File systems and databases implement CRC for integrity checking of critical data structures.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì± Mobile Communications</h4>
                                <p>Cellular networks (GSM, UMTS, LTE) employ CRC codes at multiple protocol layers. Bluetooth and other short-range protocols use CRC for reliable data transmission.</p>
                            </div>
                            <div class="application-item">
                                <h4>üõ∞Ô∏è Space & Aviation</h4>
                                <p>Satellite communication and avionics systems use CRC codes for mission-critical data integrity. NASA and ESA standards mandate specific CRC implementations for spacecraft systems.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 3: Sliding Window Protocol -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 3: Sliding Window Protocol (Go-Back-N)</h2>
                    <div class="week-badge">Flow Control</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Sliding Window Protocols represent a fundamental advancement in data link layer design, enabling efficient utilization of available bandwidth through pipelining. Unlike stop-and-wait protocols that suffer from poor utilization on high-latency links, sliding window protocols allow multiple frames to be in transit simultaneously, dramatically improving throughput.</p>
                        
                        <p>The Go-Back-N variant is particularly important as it provides a balance between implementation complexity and performance. It forms the theoretical foundation for many modern reliable transport protocols, including TCP's original design and various industrial communication protocols.</p>
                        
                        <div class="technical-details">
                            <h4>Protocol Mechanics</h4>
                            <p><strong>Window Concept:</strong> The sliding window maintains a range of sequence numbers that can be transmitted (sender window) or received (receiver window) at any given time. This window "slides" forward as acknowledgments are received.</p>
                            
                            <p><strong>Sequence Numbering:</strong> Frames are numbered modulo 2^n where n is the number of bits used for sequence numbers. The window size must be ‚â§ 2^n - 1 to avoid sequence number ambiguity.</p>
                            
                            <p><strong>Flow Control:</strong> The receiver controls the sender's transmission rate by advertising its available buffer space, preventing buffer overflow and ensuring reliable delivery.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Go-Back-N Protocol Mechanism</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/SlidingWindow.png" alt="Go-Back-N Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Core Principle:</strong> Sender can transmit up to N unacknowledged frames. If any frame is lost or corrupted, the receiver discards all subsequent frames and requests retransmission from the lost frame onwards.</p>
                                
                                <p><strong>Sender Operation:</strong></p>
                                <ol>
                                    <li><strong>Window Management:</strong> Maintains a window of size N frames that can be sent without acknowledgment</li>
                                    <li><strong>Transmission:</strong> Sends frames within the window and starts timers for each frame</li>
                                    <li><strong>Acknowledgment Processing:</strong> Slides window forward upon receiving ACK, cancels corresponding timers</li>
                                    <li><strong>Timeout Handling:</strong> Retransmits all frames from the oldest unacknowledged frame when timeout occurs</li>
                                </ol>
                                
                                <p><strong>Receiver Operation:</strong></p>
                                <ol>
                                    <li><strong>In-Order Delivery:</strong> Only accepts frames in correct sequence order</li>
                                    <li><strong>Duplicate Detection:</strong> Discards duplicate frames and re-sends last valid ACK</li>
                                    <li><strong>Error Handling:</strong> Discards out-of-order frames and requests retransmission</li>
                                    <li><strong>Cumulative ACK:</strong> Acknowledges highest correctly received frame</li>
                                </ol>
                                
                                <p><strong>Performance Characteristics:</strong></p>
                                <ul>
                                    <li><strong>Throughput:</strong> Maximum efficiency = N / (1 + 2a) where a = propagation delay / transmission delay</li>
                                    <li><strong>Buffer Requirements:</strong> Sender needs N buffers, receiver needs only 1 buffer</li>
                                    <li><strong>Error Recovery Time:</strong> Worst case = N √ó frame transmission time</li>
                                    <li><strong>Bandwidth Utilization:</strong> Can approach 100% on high-speed, low-latency links</li>
                                </ul>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Simple receiver design - no need to buffer out-of-order frames</li>
                                    <li>Cumulative acknowledgments reduce ACK traffic</li>
                                    <li>Effective for channels with low error rates</li>
                                    <li>Guarantees in-order delivery of frames</li>
                                    <li>Well-suited for simplex communication channels</li>
                                </ul>
                                
                                <p><strong>Disadvantages:</strong></p>
                                <ul>
                                    <li>Inefficient on high error rate channels (unnecessary retransmissions)</li>
                                    <li>Poor performance when propagation delay is large</li>
                                    <li>Timeout value selection is critical for performance</li>
                                    <li>Cannot utilize channel capacity during error recovery</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Advanced Window Management</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Dynamic Window Sizing:</strong> Advanced implementations adjust window size based on network conditions, receiver capacity, and error rates to optimize performance.</p>
                                
                                <p><strong>Selective Repeat vs Go-Back-N:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Aspect</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Go-Back-N</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Selective Repeat</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Buffer Complexity</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Simple (1 buffer)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Complex (N buffers)</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Retransmission</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">All frames from error</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Only lost frames</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Efficiency</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Lower on error-prone links</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Higher bandwidth utilization</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Timeout Management:</strong></p>
                                <ul>
                                    <li><strong>Fixed Timeout:</strong> Simple but may cause unnecessary retransmissions</li>
                                    <li><strong>Adaptive Timeout:</strong> Adjusts based on measured RTT (like TCP's SRTT algorithm)</li>
                                    <li><strong>Per-Frame Timeout:</strong> Individual timers for each outstanding frame</li>
                                </ul>
                                
                                <p><strong>Flow Control Integration:</strong> Modern implementations combine sliding window with flow control, where the effective window size is the minimum of congestion window and advertised window.</p>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Protocol Understanding:</strong> Master the operational mechanics of sliding window protocols and understand why they're essential for efficient data transmission</li>
                            <li><strong>Performance Analysis:</strong> Calculate theoretical and practical throughput efficiency under various network conditions and error rates</li>
                            <li><strong>Implementation Skills:</strong> Develop a complete Go-Back-N simulation including timeout handling, sequence number management, and error recovery</li>
                            <li><strong>Comparative Analysis:</strong> Understand trade-offs between Go-Back-N and Selective Repeat protocols in different network scenarios</li>
                            <li><strong>Real-world Applications:</strong> Connect the theoretical protocol to actual implementations in TCP and other transport protocols</li>
                            <li><strong>Optimization Techniques:</strong> Learn advanced techniques for optimizing sliding window performance in modern networks</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Protocol Evolution</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üåê Internet Protocols</h4>
                                <p>TCP's original design was heavily influenced by Go-Back-N principles. Modern TCP uses selective acknowledgments (SACK) but maintains the fundamental sliding window concept for flow and congestion control.</p>
                            </div>
                            <div class="application-item">
                                <h4>üõ∞Ô∏è Satellite Communications</h4>
                                <p>High-latency satellite links benefit enormously from sliding window protocols. Deep space communications use sophisticated variations to handle extremely long propagation delays.</p>
                            </div>
                            <div class="application-item">
                                <h4>üè≠ Industrial Networks</h4>
                                <p>Manufacturing and control systems use reliable sliding window protocols for real-time data exchange. Protocols like PROFINET and EtherCAT implement specialized versions for deterministic timing.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì± Wireless Networks</h4>
                                <p>WiFi (802.11) and cellular protocols use advanced sliding window mechanisms to handle the variable error rates and bandwidth characteristics of wireless channels.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 4: Dijkstra's Shortest Path Algorithm -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 4: Dijkstra's Shortest Path Algorithm</h2>
                    <div class="week-badge">Routing</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Dijkstra's shortest path algorithm stands as one of the most elegant and fundamental algorithms in computer science, with profound applications in network routing. Developed by Edsger W. Dijkstra in 1956, this algorithm solves the single-source shortest path problem in graphs with non-negative edge weights, making it ideally suited for network routing applications.</p>
                        
                        <p>In computer networks, Dijkstra's algorithm forms the computational heart of link-state routing protocols, most notably OSPF (Open Shortest Path First) and IS-IS (Intermediate System to Intermediate System). The algorithm's ability to compute optimal paths while maintaining mathematical guarantees of correctness makes it indispensable for modern internet infrastructure.</p>
                        
                        <div class="technical-details">
                            <h4>Algorithm Foundation</h4>
                            <p><strong>Graph Theory Basis:</strong> The algorithm operates on a weighted, directed graph G(V,E) where vertices represent network nodes (routers) and edges represent links with associated costs (delay, bandwidth, hop count, etc.).</p>
                            
                            <p><strong>Greedy Strategy:</strong> Dijkstra's algorithm employs a greedy approach, always selecting the closest unvisited vertex, which guarantees optimal solutions due to the optimal substructure property of shortest paths.</p>
                            
                            <p><strong>Mathematical Correctness:</strong> The algorithm's correctness relies on the principle that the shortest path from source to any vertex must pass through vertices that are themselves at minimum distance from the source.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Dijkstra's Algorithm Implementation</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/Dijkstras.png" alt="Dijkstra Algorithm Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Core Purpose:</strong> Compute the shortest path from a single source vertex to all other vertices in a weighted graph, guaranteeing optimal solutions for network routing decisions.</p>
                                
                                <p><strong>Algorithm Steps:</strong></p>
                                <ol>
                                    <li><strong>Initialization:</strong> Set distance to source as 0, all others as infinity. Mark all vertices as unvisited.</li>
                                    <li><strong>Selection:</strong> Choose unvisited vertex with minimum distance (initially the source)</li>
                                    <li><strong>Relaxation:</strong> Update distances to all adjacent vertices if shorter path found</li>
                                    <li><strong>Marking:</strong> Mark current vertex as visited (permanent distance established)</li>
                                    <li><strong>Iteration:</strong> Repeat steps 2-4 until all vertices visited or target reached</li>
                                </ol>
                                
                                <p><strong>Data Structures:</strong></p>
                                <ul>
                                    <li><strong>Distance Array:</strong> Maintains current shortest distance to each vertex</li>
                                    <li><strong>Predecessor Array:</strong> Tracks the path for reconstruction</li>
                                    <li><strong>Priority Queue:</strong> Efficiently selects minimum distance vertex (O(log V) operations)</li>
                                    <li><strong>Visited Set:</strong> Tracks vertices with finalized shortest distances</li>
                                </ul>
                                
                                <p><strong>Complexity Analysis:</strong></p>
                                <ul>
                                    <li><strong>Time Complexity:</strong> O((V + E) log V) with binary heap, O(V¬≤) with simple array</li>
                                    <li><strong>Space Complexity:</strong> O(V) for distance and predecessor arrays</li>
                                    <li><strong>Practical Performance:</strong> Excellent for sparse graphs typical in network topologies</li>
                                    <li><strong>Scalability:</strong> Handles networks with thousands of nodes efficiently</li>
                                </ul>
                                
                                <p><strong>Advantages in Networking:</strong></p>
                                <ul>
                                    <li>Guaranteed optimal shortest paths (unlike heuristic methods)</li>
                                    <li>Handles arbitrary positive link weights (delay, cost, bandwidth)</li>
                                    <li>Supports precomputation for fast route lookups</li>
                                    <li>Deterministic behavior aids in network troubleshooting</li>
                                    <li>Adaptable to dynamic topology changes</li>
                                </ul>
                                
                                <p><strong>Limitations:</strong></p>
                                <ul>
                                    <li>Requires complete topology knowledge (link-state database)</li>
                                    <li>Cannot handle negative edge weights</li>
                                    <li>Computational overhead increases with network size</li>
                                    <li>Sensitive to topology change frequency</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Network Routing Applications</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>OSPF Protocol Integration:</strong> Open Shortest Path First uses Dijkstra's algorithm as its core route computation engine, running the algorithm each time the link-state database changes.</p>
                                
                                <p><strong>Link-State Routing Process:</strong></p>
                                <ol>
                                    <li><strong>Topology Discovery:</strong> Each router floods link-state advertisements (LSAs)</li>
                                    <li><strong>Database Synchronization:</strong> All routers maintain identical topology database</li>
                                    <li><strong>SPF Calculation:</strong> Each router runs Dijkstra's algorithm independently</li>
                                    <li><strong>Routing Table Construction:</strong> Results populate the IP routing table</li>
                                </ol>
                                
                                <p><strong>Advanced Routing Concepts:</strong></p>
                                <ul>
                                    <li><strong>Multi-Area OSPF:</strong> Hierarchical routing reduces computation overhead</li>
                                    <li><strong>Traffic Engineering:</strong> Explicit path computation for QoS and load balancing</li>
                                    <li><strong>Fast Reroute:</strong> Pre-computed backup paths for sub-second failover</li>
                                    <li><strong>Equal-Cost Multi-Path (ECMP):</strong> Load distribution across multiple optimal paths</li>
                                </ul>
                                
                                <p><strong>Modern Adaptations:</strong></p>
                                <ul>
                                    <li><strong>Software-Defined Networks (SDN):</strong> Centralized controllers use Dijkstra's for global optimization</li>
                                    <li><strong>Segment Routing:</strong> Source-based routing with Dijkstra-computed paths</li>
                                    <li><strong>Network Function Virtualization:</strong> Virtual network overlay path computation</li>
                                    <li><strong>5G Networks:</strong> Ultra-low latency path selection for critical applications</li>
                                </ul>
                                
                                <p><strong>Performance Optimizations:</strong></p>
                                <ul>
                                    <li><strong>Incremental SPF:</strong> Recompute only affected portions of the tree</li>
                                    <li><strong>Fibonacci Heaps:</strong> O(E + V log V) complexity for dense graphs</li>
                                    <li><strong>Parallel Processing:</strong> Multi-threaded implementations for large networks</li>
                                    <li><strong>Caching Strategies:</strong> Store computed paths for frequent source-destination pairs</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Algorithm Variants & Extensions</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Bidirectional Dijkstra:</strong> Searches simultaneously from source and destination, potentially halving the search space for single pair shortest path queries.</p>
                                
                                <p><strong>A* Algorithm:</strong> Extends Dijkstra's with heuristic guidance, particularly useful for geographic routing and network path planning with coordinate information.</p>
                                
                                <p><strong>Constrained Shortest Path:</strong></p>
                                <ul>
                                    <li><strong>Delay-Constrained:</strong> Find shortest path with maximum delay constraint</li>
                                    <li><strong>Bandwidth-Constrained:</strong> Path selection considering minimum bandwidth requirements</li>
                                    <li><strong>Multi-Constraint:</strong> Optimize multiple metrics simultaneously (delay, jitter, loss)</li>
                                </ul>
                                
                                <p><strong>Dynamic Shortest Paths:</strong></p>
                                <ul>
                                    <li><strong>Decremental Algorithms:</strong> Efficiently handle link failures</li>
                                    <li><strong>Incremental Algorithms:</strong> Add new links without full recomputation</li>
                                    <li><strong>Fully Dynamic:</strong> Handle arbitrary topology changes</li>
                                </ul>
                                
                                <p><strong>Comparison with Other Algorithms:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Algorithm</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Use Case</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Complexity</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Notes</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Dijkstra's</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Single-source, non-negative weights</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O((V+E) log V)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">OSPF, IS-IS</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Bellman-Ford</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Negative weights allowed</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(VE)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">RIP, BGP distance vector</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Floyd-Warshall</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">All-pairs shortest paths</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(V¬≥)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Small networks, reachability</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Algorithm Mastery:</strong> Understand and implement Dijkstra's algorithm with various data structures and optimizations</li>
                            <li><strong>Complexity Analysis:</strong> Analyze time and space complexity trade-offs for different implementation approaches</li>
                            <li><strong>Network Applications:</strong> Connect the algorithm to real-world routing protocols and understand its role in internet infrastructure</li>
                            <li><strong>Performance Optimization:</strong> Learn techniques for optimizing shortest path computation in large-scale networks</li>
                            <li><strong>Comparative Understanding:</strong> Evaluate Dijkstra's algorithm against alternatives for different network scenarios</li>
                            <li><strong>Advanced Variants:</strong> Explore extensions and modifications for specialized routing requirements</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Usage</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üåê Internet Routing</h4>
                                <p>OSPF and IS-IS protocols use Dijkstra's algorithm to compute shortest paths in autonomous systems. BGP uses it for path selection within routing policies and communities.</p>
                            </div>
                            <div class="application-item">
                                <h4>üó∫Ô∏è Navigation Systems</h4>
                                <p>GPS navigation, Google Maps, and ride-sharing applications use variations of Dijkstra's algorithm for route planning, considering real-time traffic and road conditions.</p>
                            </div>
                            <div class="application-item">
                                <h4>‚òÅÔ∏è Cloud Networks</h4>
                                <p>Software-defined networks in cloud data centers use centralized Dijkstra implementations for traffic engineering, load balancing, and network slicing in multi-tenant environments.</p>
                            </div>
                            <div class="application-item">
                                <h4>üéÆ Game Development</h4>
                                <p>AI pathfinding in video games, MMORPGs use Dijkstra's and A* algorithms for NPC movement, quest routing, and procedural world generation with optimal traversal paths.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 5: Broadcast Tree for a Subnet -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 5: Broadcast Tree for a Subnet</h2>
                    <div class="week-badge">Broadcasting</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Broadcast tree construction is a fundamental problem in network communication that addresses the challenge of efficiently distributing information from one source to all nodes in a network. Unlike point-to-point communication, broadcasting requires careful consideration of network topology to avoid redundant transmissions, broadcast storms, and excessive bandwidth consumption.</p>
                        
                        <p>The concept of broadcast trees is deeply rooted in graph theory, specifically in the construction of spanning trees. A spanning tree of a connected graph is a subgraph that connects all vertices with the minimum number of edges (V-1 edges for V vertices), ensuring no cycles exist while maintaining connectivity. In networking context, this translates to optimal broadcast paths that reach every node exactly once.</p>
                        
                        <div class="technical-details">
                            <h4>Mathematical Foundation</h4>
                            <p><strong>Spanning Tree Properties:</strong> For a connected graph G(V,E), any spanning tree T contains exactly |V|-1 edges and maintains connectivity while eliminating all cycles.</p>
                            
                            <p><strong>Broadcast Efficiency:</strong> A properly constructed broadcast tree ensures that each message is transmitted exactly once on each tree edge, minimizing total network traffic from O(|E|) to O(|V|).</p>
                            
                            <p><strong>Tree Metrics:</strong> Different algorithms optimize for various metrics including total cost, maximum hop count, maximum degree, or load balancing across network links.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Breadth-First Search (BFS) Spanning Tree</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/Broadcast.png" alt="Broadcast Tree Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Core Algorithm:</strong> BFS constructs a spanning tree by exploring nodes level by level from a designated root, ensuring minimum hop count from source to all destinations.</p>
                                
                                <p><strong>Algorithm Steps:</strong></p>
                                <ol>
                                    <li><strong>Initialization:</strong> Select broadcast source as root, mark as visited</li>
                                    <li><strong>Level Exploration:</strong> Add all unvisited neighbors to queue</li>
                                    <li><strong>Tree Construction:</strong> For each dequeued node, add edges to unvisited neighbors</li>
                                    <li><strong>Iteration:</strong> Continue until all nodes are visited</li>
                                    <li><strong>Result:</strong> Minimum-hop broadcast tree rooted at source</li>
                                </ol>
                                
                                <p><strong>Properties of BFS Tree:</strong></p>
                                <ul>
                                    <li><strong>Minimum Depth:</strong> Guarantees shortest path (in hops) from root to all nodes</li>
                                    <li><strong>Level Structure:</strong> Nodes at distance d form level d of the tree</li>
                                    <li><strong>Breadth-First Property:</strong> All nodes at level k are explored before level k+1</li>
                                    <li><strong>Optimal Broadcast Delay:</strong> Minimizes maximum delay for broadcast completion</li>
                                </ul>
                                
                                <p><strong>Performance Characteristics:</strong></p>
                                <ul>
                                    <li><strong>Time Complexity:</strong> O(V + E) for adjacency list representation</li>
                                    <li><strong>Space Complexity:</strong> O(V) for queue and visited array</li>
                                    <li><strong>Message Complexity:</strong> Exactly V-1 messages in the spanning tree</li>
                                    <li><strong>Broadcast Delay:</strong> O(diameter of network) in the best case</li>
                                </ul>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Guarantees minimum broadcast delay (hop count)</li>
                                    <li>Simple implementation and understanding</li>
                                    <li>Deterministic behavior aids in network analysis</li>
                                    <li>Optimal for time-sensitive broadcast applications</li>
                                    <li>Well-suited for unweighted networks</li>
                                </ul>
                                
                                <p><strong>Limitations:</strong></p>
                                <ul>
                                    <li>Does not consider link weights or capacities</li>
                                    <li>May not minimize total cost in weighted networks</li>
                                    <li>Root selection significantly impacts tree quality</li>
                                    <li>No load balancing considerations</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Alternative Spanning Tree Algorithms</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Minimum Spanning Tree (MST) Approaches:</strong> When link weights represent costs, delays, or capacities, MST algorithms provide optimal broadcast trees for different metrics.</p>
                                
                                <p><strong>Prim's Algorithm for Broadcast Trees:</strong></p>
                                <ol>
                                    <li><strong>Initialization:</strong> Start with broadcast source in tree</li>
                                    <li><strong>Greedy Selection:</strong> Add minimum weight edge connecting tree to non-tree node</li>
                                    <li><strong>Tree Expansion:</strong> Include selected node in growing tree</li>
                                    <li><strong>Termination:</strong> Continue until all nodes included</li>
                                </ol>
                                
                                <p><strong>Kruskal's Algorithm Adaptation:</strong></p>
                                <ol>
                                    <li><strong>Edge Sorting:</strong> Sort all edges by weight</li>
                                    <li><strong>Cycle Detection:</strong> Use Union-Find to detect cycles</li>
                                    <li><strong>Edge Selection:</strong> Add edges that don't create cycles</li>
                                    <li><strong>Tree Completion:</strong> Stop when V-1 edges selected</li>
                                </ol>
                                
                                <p><strong>Specialized Broadcast Tree Variants:</strong></p>
                                <ul>
                                    <li><strong>Shortest Path Tree:</strong> Dijkstra-based, optimizes cumulative distance</li>
                                    <li><strong>Minimum Degree Tree:</strong> Minimizes maximum node degree for load balancing</li>
                                    <li><strong>Bounded Diameter Tree:</strong> Constraints maximum hop count while optimizing cost</li>
                                    <li><strong>Steiner Tree:</strong> Allows additional relay nodes for optimal connectivity</li>
                                </ul>
                                
                                <p><strong>Algorithm Comparison:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Algorithm</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Optimizes</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Complexity</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Best Use Case</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>BFS Tree</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Broadcast delay</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(V + E)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Time-critical broadcasts</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>MST (Prim's)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Total cost</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(E log V)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Cost-sensitive networks</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>SPT (Dijkstra)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Cumulative distance</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O((V+E) log V)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Weighted delay optimization</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Network Protocol Applications</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Spanning Tree Protocol (STP):</strong> IEEE 802.1D uses spanning tree algorithms to prevent loops in Ethernet networks while maintaining connectivity for broadcast frames.</p>
                                
                                <p><strong>STP Operation:</strong></p>
                                <ol>
                                    <li><strong>Root Bridge Selection:</strong> Bridge with lowest ID becomes root</li>
                                    <li><strong>Path Cost Calculation:</strong> Each bridge calculates cost to root</li>
                                    <li><strong>Port Role Assignment:</strong> Designate root, designated, and blocked ports</li>
                                    <li><strong>Topology Convergence:</strong> Block redundant paths to eliminate loops</li>
                                </ol>
                                
                                <p><strong>Multicast Routing Applications:</strong></p>
                                <ul>
                                    <li><strong>PIM (Protocol Independent Multicast):</strong> Builds distribution trees for multicast groups</li>
                                    <li><strong>DVMRP (Distance Vector Multicast):</strong> Uses reverse path forwarding with spanning trees</li>
                                    <li><strong>MOSPF (Multicast OSPF):</strong> Extends OSPF with multicast spanning tree computation</li>
                                </ul>
                                
                                <p><strong>Wireless Network Broadcasting:</strong></p>
                                <ul>
                                    <li><strong>Ad-hoc Networks:</strong> Dynamic spanning tree construction for mobile nodes</li>
                                    <li><strong>Sensor Networks:</strong> Energy-efficient broadcast trees for battery-constrained devices</li>
                                    <li><strong>Mesh Networks:</strong> Robust broadcast trees with fault tolerance</li>
                                </ul>
                                
                                <p><strong>Modern Applications:</strong></p>
                                <ul>
                                    <li><strong>Software-Defined Networks:</strong> Centralized broadcast tree computation</li>
                                    <li><strong>Data Center Networks:</strong> Optimized broadcast for cloud applications</li>
                                    <li><strong>IoT Networks:</strong> Lightweight broadcast protocols for constrained devices</li>
                                    <li><strong>Blockchain Networks:</strong> Efficient transaction broadcast mechanisms</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Graph Theory Mastery:</strong> Understand spanning tree properties and their relationship to network broadcast efficiency</li>
                            <li><strong>Algorithm Implementation:</strong> Develop and optimize BFS-based spanning tree algorithms for various network topologies</li>
                            <li><strong>Performance Analysis:</strong> Evaluate broadcast tree quality using metrics like delay, cost, and bandwidth utilization</li>
                            <li><strong>Protocol Understanding:</strong> Connect theoretical spanning trees to real network protocols like STP and multicast routing</li>
                            <li><strong>Optimization Techniques:</strong> Learn advanced techniques for constructing optimal broadcast trees under various constraints</li>
                            <li><strong>Practical Applications:</strong> Apply broadcast tree concepts to modern networking scenarios including wireless and data center networks</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Usage</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üåê Ethernet Networks</h4>
                                <p>Spanning Tree Protocol (STP) and its variants (RSTP, MSTP) use spanning tree algorithms to prevent broadcast storms in switched Ethernet networks while maintaining redundancy for fault tolerance.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì° Multicast Streaming</h4>
                                <p>Video streaming services, live broadcasts, and financial data feeds use multicast spanning trees to efficiently distribute content from sources to multiple subscribers simultaneously.</p>
                            </div>
                            <div class="application-item">
                                <h4>üè≠ Industrial IoT</h4>
                                <p>Smart manufacturing systems use energy-efficient broadcast trees for sensor data collection, firmware updates, and coordinated control commands across distributed industrial networks.</p>
                            </div>
                            <div class="application-item">
                                <h4>üéÆ Online Gaming</h4>
                                <p>Massively multiplayer games use optimized broadcast trees for distributing game state updates, chat messages, and event notifications to thousands of concurrent players in real-time.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 6: Distance Vector Routing Algorithm -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 6: Distance Vector Routing Algorithm</h2>
                    <div class="week-badge">Dynamic Routing</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Distance Vector Routing represents a fundamental paradigm in distributed network routing, embodying the principle of "routing by rumor." Unlike link-state protocols that maintain complete topology databases, distance vector algorithms operate on limited local information, with each router knowing only the cost to reach destinations through its direct neighbors.</p>
                        
                        <p>This approach, rooted in the Bellman-Ford algorithm, enables automatic route discovery and adaptation in dynamic networks. While simpler to implement than link-state protocols, distance vector routing faces unique challenges including slow convergence, routing loops, and the infamous "count-to-infinity" problem that has shaped the evolution of modern routing protocols.</p>
                        
                        <div class="technical-details">
                            <h4>Algorithmic Foundation</h4>
                            <p><strong>Bellman-Ford Equation:</strong> The core principle states that the shortest distance from node i to destination d is: D[i,d] = min{c[i,j] + D[j,d]} for all neighbors j, where c[i,j] is the direct cost from i to j.</p>
                            
                            <p><strong>Distributed Computation:</strong> Each router independently applies the Bellman-Ford equation using distance vectors received from neighbors, enabling distributed shortest path computation without global coordination.</p>
                            
                            <p><strong>Asynchronous Updates:</strong> Routers exchange distance vectors periodically and upon topology changes, allowing the network to adapt to failures and new links without centralized control.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Bellman-Ford Distributed Algorithm</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/DistanceVectorRouting.png" alt="Distance Vector Diagram">
                            </div>
                            <div class="concept-description">
                                <p><strong>Core Mechanism:</strong> Each router maintains a distance vector containing its current best estimate of distance to every network destination, updating these estimates based on information received from neighbors.</p>
                                
                                <p><strong>Algorithm Steps:</strong></p>
                                <ol>
                                    <li><strong>Initialization:</strong> Each router sets distance to itself as 0, direct neighbors as link cost, others as infinity</li>
                                    <li><strong>Periodic Updates:</strong> Routers send their distance vectors to all direct neighbors</li>
                                    <li><strong>Distance Computation:</strong> Upon receiving updates, apply Bellman-Ford equation to compute new shortest distances</li>
                                    <li><strong>Route Table Update:</strong> Update routing table if shorter paths are discovered</li>
                                    <li><strong>Convergence:</strong> Process continues until no more improvements can be made</li>
                                </ol>
                                
                                <p><strong>Data Structures:</strong></p>
                                <ul>
                                    <li><strong>Distance Vector:</strong> Array D[destination] storing shortest known distance to each destination</li>
                                    <li><strong>Next Hop Table:</strong> Maps each destination to the next hop router on the shortest path</li>
                                    <li><strong>Neighbor Cost Table:</strong> Direct link costs to immediate neighbors</li>
                                    <li><strong>Routing Table:</strong> Final forwarding table derived from distance computations</li>
                                </ul>
                                
                                <p><strong>Convergence Properties:</strong></p>
                                <ul>
                                    <li><strong>Good News Travels Fast:</strong> Decreased distances propagate quickly through the network</li>
                                    <li><strong>Bad News Travels Slowly:</strong> Link failures may cause slow convergence due to count-to-infinity</li>
                                    <li><strong>Finite Convergence:</strong> Guaranteed to converge in finite time for stable topologies</li>
                                    <li><strong>Time Complexity:</strong> O(n√ód) iterations where n is network diameter and d is number of destinations</li>
                                </ul>
                                
                                <p><strong>Advantages:</strong></p>
                                <ul>
                                    <li>Simple implementation with minimal memory requirements</li>
                                    <li>Distributed operation requires no global coordination</li>
                                    <li>Automatic route discovery and adaptation</li>
                                    <li>Handles arbitrary network topologies</li>
                                    <li>Scales well with number of routers</li>
                                    <li>Self-configuring with minimal administration</li>
                                </ul>
                                
                                <p><strong>Disadvantages:</strong></p>
                                <ul>
                                    <li>Count-to-infinity problem causes slow convergence</li>
                                    <li>Routing loops during convergence periods</li>
                                    <li>Limited hop count constrains network diameter</li>
                                    <li>Poor bandwidth utilization due to periodic updates</li>
                                    <li>No support for hierarchical routing</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Loop Prevention Mechanisms</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Count-to-Infinity Problem:</strong> When a link fails, routers may form counting loops, incrementally increasing distances until reaching infinity (typically 16 hops in RIP).</p>
                                
                                <p><strong>Split Horizon Technique:</strong></p>
                                <ul>
                                    <li><strong>Basic Split Horizon:</strong> Never advertise a route back to the neighbor from which it was learned</li>
                                    <li><strong>Split Horizon with Poison Reverse:</strong> Advertise routes back to their source with infinite distance</li>
                                    <li><strong>Effectiveness:</strong> Prevents two-node loops but cannot handle larger loop scenarios</li>
                                </ul>
                                
                                <p><strong>Route Poisoning:</strong></p>
                                <ol>
                                    <li>When a route fails, immediately advertise it with infinite distance</li>
                                    <li>Triggered updates propagate the failure information quickly</li>
                                    <li>Hold-down timers prevent premature route reinstatement</li>
                                    <li>Flush timers remove invalid routes from tables</li>
                                </ol>
                                
                                <p><strong>Advanced Loop Prevention:</strong></p>
                                <ul>
                                    <li><strong>Path Vector:</strong> Include complete path information to detect loops (BGP approach)</li>
                                    <li><strong>Sequence Numbers:</strong> Version control for routing updates</li>
                                    <li><strong>Loop-Free Invariants:</strong> Mathematical conditions ensuring loop-free routing</li>
                                    <li><strong>Diffusing Computation:</strong> DUAL algorithm used in EIGRP</li>
                                </ul>
                                
                                <p><strong>Timing Considerations:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Timer</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Purpose</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Typical Value</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Impact</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Update Timer</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Periodic advertisements</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">30 seconds</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Bandwidth vs. freshness trade-off</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Invalid Timer</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Route expiration</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">180 seconds</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Failure detection speed</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Hold-down Timer</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Prevent route flapping</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">180 seconds</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Stability vs. recovery time</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Flush Timer</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Route removal</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">240 seconds</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Memory cleanup</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>RIP Protocol Implementation</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Routing Information Protocol (RIP):</strong> The most widely deployed distance vector protocol, implementing classical Bellman-Ford with practical enhancements for real networks.</p>
                                
                                <p><strong>RIP Message Format:</strong></p>
                                <ul>
                                    <li><strong>Request Messages:</strong> Solicit routing information from neighbors</li>
                                    <li><strong>Response Messages:</strong> Contain distance vector information</li>
                                    <li><strong>Route Entries:</strong> Network address, subnet mask, next hop, metric</li>
                                    <li><strong>Authentication:</strong> Optional security for routing updates</li>
                                </ul>
                                
                                <p><strong>RIP Versions Comparison:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Feature</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">RIPv1</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">RIPv2</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">RIPng</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Addressing</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Classful IPv4</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">CIDR IPv4</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">IPv6</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Subnet Masks</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">No</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Yes</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Prefix length</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Authentication</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">None</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">MD5/Text</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">IPSec</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Multicast</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Broadcast</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">224.0.0.9</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">FF02::9</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Modern Enhancements:</strong></p>
                                <ul>
                                    <li><strong>Triggered Updates:</strong> Immediate propagation of topology changes</li>
                                    <li><strong>Route Summarization:</strong> Aggregation of multiple routes to reduce table size</li>
                                    <li><strong>Administrative Distance:</strong> Priority mechanism for multi-protocol environments</li>
                                    <li><strong>Load Balancing:</strong> Equal-cost path utilization</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Algorithm Understanding:</strong> Master the Bellman-Ford distributed algorithm and its application to network routing</li>
                            <li><strong>Problem Analysis:</strong> Understand the count-to-infinity problem and various loop prevention mechanisms</li>
                            <li><strong>Protocol Implementation:</strong> Develop practical understanding of RIP protocol operations and message formats</li>
                            <li><strong>Convergence Analysis:</strong> Analyze convergence properties and timing considerations in dynamic networks</li>
                            <li><strong>Comparative Study:</strong> Compare distance vector with link-state routing in terms of scalability and performance</li>
                            <li><strong>Troubleshooting Skills:</strong> Diagnose and resolve common distance vector routing issues</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Protocol Evolution</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üè¢ Enterprise Networks</h4>
                                <p>RIP remains popular in small enterprise networks due to its simplicity and zero-configuration setup. Modern implementations include authentication and route filtering for enhanced security.</p>
                            </div>
                            <div class="application-item">
                                <h4>üåê Internet Backbone</h4>
                                <p>BGP (Border Gateway Protocol) uses path vector (evolution of distance vector) for inter-domain routing, handling the global internet with policy-based routing and loop prevention.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì° Wireless Mesh Networks</h4>
                                <p>AODV and DSDV protocols in mobile ad-hoc networks use distance vector principles adapted for wireless environments with frequent topology changes and energy constraints.</p>
                            </div>
                            <div class="application-item">
                                <h4>üè≠ Industrial Control Systems</h4>
                                <p>Process control networks use simplified distance vector protocols for deterministic routing in closed industrial environments where simplicity and reliability are paramount.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 7: Data Encryption and Decryption -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 7: Data Encryption and Decryption</h2>
                    <div class="week-badge">Security</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Data encryption forms the cornerstone of modern network security, transforming readable plaintext into unintelligible ciphertext through mathematical algorithms. In an era where data breaches cost organizations millions and cyber threats evolve continuously, understanding cryptographic principles is essential for network professionals. This week explores the fundamental cryptographic algorithms that protect data integrity, confidentiality, and authenticity across digital communications.</p>
                        
                        <p>From ancient Caesar ciphers to modern AES encryption, cryptographic evolution reflects humanity's constant battle between information protection and unauthorized access. Network encryption operates at multiple layers, securing everything from web browsing (HTTPS) to virtual private networks (VPNs), email communications, and cloud storage. Understanding both symmetric and asymmetric encryption enables secure network design and implementation.</p>
                        
                        <div class="technical-details">
                            <h4>Cryptographic Foundations</h4>
                            <p><strong>Information Theoretic Security:</strong> Perfect secrecy, as defined by Claude Shannon, requires that ciphertext provides no information about plaintext, achievable only with one-time pads of truly random keys equal in length to the message.</p>
                            
                            <p><strong>Computational Security:</strong> Practical cryptography relies on computational intractability - algorithms that would require infeasible computational resources (time, memory, or energy) to break using current technology.</p>
                            
                            <p><strong>Kerckhoffs's Principle:</strong> Security should depend entirely on key secrecy, not algorithm secrecy. Modern cryptographic algorithms are publicly scrutinized to identify and eliminate vulnerabilities.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Classical Cipher Systems</h4>
                                <span class="difficulty-badge easy">Basic</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/DataEncryptionAndDecryption.png" alt="Classical Encryption">
                            </div>
                            <div class="concept-description">
                                <p><strong>Caesar Cipher (Shift Cipher):</strong> The simplest substitution cipher, shifting each letter by a fixed number of positions in the alphabet. Despite its simplicity, it introduces fundamental encryption concepts including key space, frequency analysis, and brute force attacks.</p>
                                
                                <p><strong>Implementation Details:</strong></p>
                                <ul>
                                    <li><strong>Encryption:</strong> C = (P + K) mod 26, where P is plaintext, K is key, C is ciphertext</li>
                                    <li><strong>Decryption:</strong> P = (C - K) mod 26</li>
                                    <li><strong>Key Space:</strong> Only 25 possible keys (excluding identity transformation)</li>
                                    <li><strong>Vulnerability:</strong> Susceptible to frequency analysis and brute force attacks</li>
                                </ul>
                                
                                <p><strong>Polyalphabetic Ciphers:</strong></p>
                                <ul>
                                    <li><strong>Vigen√®re Cipher:</strong> Uses repeating keyword to vary substitution, resisting simple frequency analysis</li>
                                    <li><strong>Beaufort Cipher:</strong> Variant using subtraction operation for encryption</li>
                                    <li><strong>Kasiski Examination:</strong> Cryptanalytic technique exploiting periodic key repetition</li>
                                    <li><strong>Index of Coincidence:</strong> Statistical measure for determining key length</li>
                                </ul>
                                
                                <p><strong>Transposition Ciphers:</strong></p>
                                <ul>
                                    <li><strong>Columnar Transposition:</strong> Rearranges character positions based on key permutation</li>
                                    <li><strong>Route Ciphers:</strong> Follow specific paths through character matrices</li>
                                    <li><strong>Rail Fence Cipher:</strong> Writes text in zigzag pattern across multiple rows</li>
                                    <li><strong>Block Ciphers:</strong> Modern evolution incorporating both substitution and transposition</li>
                                </ul>
                                
                                <p><strong>Historical Impact:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Cipher</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Time Period</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Notable Use</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Cryptanalysis</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Caesar</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">50 BCE</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Roman military</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Brute force</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Vigen√®re</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">1553 CE</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Diplomatic communications</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Kasiski (1863)</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Enigma</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">1918-1945</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">German military (WWII)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Bletchley Park</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Symmetric Encryption Algorithms</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Advanced Encryption Standard (AES):</strong> The current gold standard for symmetric encryption, adopted by the U.S. government and used worldwide for protecting sensitive data. AES operates on 128-bit blocks with key sizes of 128, 192, or 256 bits.</p>
                                
                                <p><strong>AES Algorithm Structure:</strong></p>
                                <ol>
                                    <li><strong>Key Expansion:</strong> Generate round keys from main encryption key using Rijndael key schedule</li>
                                    <li><strong>Initial Round:</strong> AddRoundKey operation with original key</li>
                                    <li><strong>Main Rounds:</strong> SubBytes (S-box substitution), ShiftRows, MixColumns, AddRoundKey</li>
                                    <li><strong>Final Round:</strong> SubBytes, ShiftRows, AddRoundKey (no MixColumns)</li>
                                </ol>
                                
                                <p><strong>AES Operations Deep Dive:</strong></p>
                                <ul>
                                    <li><strong>SubBytes:</strong> Non-linear byte substitution using lookup table based on multiplicative inverse in GF(2^8)</li>
                                    <li><strong>ShiftRows:</strong> Cyclically shifts last three rows of state matrix</li>
                                    <li><strong>MixColumns:</strong> Matrix multiplication in GF(2^8) providing inter-byte diffusion</li>
                                    <li><strong>AddRoundKey:</strong> XOR operation with round key for confusion</li>
                                </ul>
                                
                                <p><strong>Block Cipher Modes of Operation:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Mode</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Description</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Advantages</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Disadvantages</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>ECB</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Electronic Codebook</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Simple, parallelizable</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Pattern preservation, insecure</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>CBC</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Cipher Block Chaining</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Good diffusion, widely supported</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Sequential, padding oracle attacks</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>CTR</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Counter Mode</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Parallelizable, stream-like</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Nonce reuse catastrophic</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>GCM</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Galois/Counter Mode</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Authenticated encryption</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Complex implementation</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Performance Characteristics:</strong></p>
                                <ul>
                                    <li><strong>AES-128:</strong> ~10 cycles/byte on modern processors with AES-NI</li>
                                    <li><strong>Hardware Acceleration:</strong> Intel AES-NI, ARM Crypto Extensions</li>
                                    <li><strong>Side-Channel Resistance:</strong> Constant-time implementations prevent timing attacks</li>
                                    <li><strong>Quantum Resistance:</strong> Grover's algorithm reduces effective key size by half</li>
                                </ul>
                                
                                <p><strong>Alternative Symmetric Algorithms:</strong></p>
                                <ul>
                                    <li><strong>ChaCha20:</strong> Stream cipher with excellent performance on devices without AES hardware</li>
                                    <li><strong>Salsa20:</strong> Predecessor to ChaCha20 with similar design principles</li>
                                    <li><strong>Blowfish/Twofish:</strong> Legacy algorithms superseded by AES</li>
                                    <li><strong>DES/3DES:</strong> Obsolete algorithms vulnerable to brute force attacks</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Asymmetric Cryptography & Network Security</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Public Key Cryptography Revolution:</strong> Introduced by Diffie-Hellman in 1976, asymmetric cryptography solved the key distribution problem by using mathematically related key pairs: public keys for encryption/verification and private keys for decryption/signing.</p>
                                
                                <p><strong>RSA Algorithm (Rivest-Shamir-Adleman):</strong></p>
                                <ol>
                                    <li><strong>Key Generation:</strong> Select two large primes p and q, compute n = p√óq and œÜ(n) = (p-1)(q-1)</li>
                                    <li><strong>Public Key:</strong> Choose e (typically 65537) coprime to œÜ(n), public key is (n, e)</li>
                                    <li><strong>Private Key:</strong> Compute d = e^(-1) mod œÜ(n), private key is (n, d)</li>
                                    <li><strong>Encryption:</strong> C = M^e mod n</li>
                                    <li><strong>Decryption:</strong> M = C^d mod n</li>
                                </ol>
                                
                                <p><strong>Elliptic Curve Cryptography (ECC):</strong></p>
                                <ul>
                                    <li><strong>Mathematical Foundation:</strong> Based on discrete logarithm problem over elliptic curves</li>
                                    <li><strong>Efficiency:</strong> 256-bit ECC provides security equivalent to 3072-bit RSA</li>
                                    <li><strong>Popular Curves:</strong> secp256r1 (NIST P-256), Curve25519, secp256k1 (Bitcoin)</li>
                                    <li><strong>Advantages:</strong> Smaller keys, faster operations, lower power consumption</li>
                                </ul>
                                
                                <p><strong>Digital Signatures:</strong></p>
                                <ul>
                                    <li><strong>RSA Signatures:</strong> S = H(M)^d mod n, verification: H(M) = S^e mod n</li>
                                    <li><strong>ECDSA:</strong> Elliptic curve variant providing authentication and non-repudiation</li>
                                    <li><strong>EdDSA:</strong> Modern signature scheme (Ed25519) with deterministic nonces</li>
                                    <li><strong>Hash Functions:</strong> SHA-256, SHA-3 for message integrity in signature schemes</li>
                                </ul>
                                
                                <p><strong>Key Exchange Protocols:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Protocol</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Security Basis</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Properties</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Applications</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Diffie-Hellman</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Discrete logarithm</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Forward secrecy</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">TLS, IPSec, SSH</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>ECDH</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Elliptic curve DLP</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Compact keys</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Modern TLS, Signal</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>RSA Key Transport</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Integer factorization</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">No forward secrecy</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Legacy TLS</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>X25519</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Curve25519 ECDH</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">High performance</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">WireGuard, modern protocols</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Network Security Applications:</strong></p>
                                <ul>
                                    <li><strong>TLS/SSL:</strong> Hybrid cryptography combining RSA/ECDH key exchange with AES encryption</li>
                                    <li><strong>IPSec VPNs:</strong> ESP protocol using AES-GCM for authenticated encryption</li>
                                    <li><strong>SSH:</strong> Secure shell using Ed25519 keys and ChaCha20-Poly1305 encryption</li>
                                    <li><strong>PGP/GPG:</strong> Email encryption combining RSA and symmetric algorithms</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Cryptographic Foundations:</strong> Master fundamental concepts including confusion, diffusion, and perfect secrecy</li>
                            <li><strong>Algorithm Implementation:</strong> Implement classical ciphers and understand their cryptanalytic vulnerabilities</li>
                            <li><strong>Modern Encryption:</strong> Understand AES algorithm structure, modes of operation, and security properties</li>
                            <li><strong>Public Key Systems:</strong> Master RSA and ECC algorithms, key generation, and digital signatures</li>
                            <li><strong>Protocol Security:</strong> Analyze cryptographic protocols used in network security (TLS, IPSec, SSH)</li>
                            <li><strong>Security Assessment:</strong> Evaluate encryption strength, identify vulnerabilities, and select appropriate algorithms</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Cryptography</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üîí Web Security (HTTPS/TLS)</h4>
                                <p>Modern web applications use TLS 1.3 with X25519 key exchange, AES-256-GCM encryption, and certificate-based authentication for secure communications between browsers and servers.</p>
                            </div>
                            <div class="application-item">
                                <h4>‚òÅÔ∏è Cloud Data Protection</h4>
                                <p>Cloud providers implement envelope encryption using customer-managed keys (CMKs) for data encryption keys (DEKs), providing data sovereignty and compliance with regulations like GDPR.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì± Mobile Device Security</h4>
                                <p>Smartphones use hardware security modules (HSMs) and ARM TrustZone for key storage, implementing full disk encryption and secure messaging with end-to-end encryption.</p>
                            </div>
                            <div class="application-item">
                                <h4>‚ö° High-Performance Computing</h4>
                                <p>Modern CPUs include AES-NI and SHA extensions for hardware-accelerated cryptography, enabling line-rate encryption in network appliances and data centers.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 8: Congestion Control (Leaky Bucket) -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 8: Congestion Control (Leaky Bucket)</h2>
                    <div class="week-badge">Traffic Shaping</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Congestion control represents one of the most critical challenges in modern networking, addressing the fundamental tension between maximizing network utilization and maintaining stable performance. The Leaky Bucket algorithm, introduced in the 1980s, provides an elegant solution for traffic shaping and rate limiting, functioning as a virtual regulator that smooths bursty traffic patterns into consistent, predictable flows.</p>
                        
                        <p>In an era of diverse applications with varying traffic characteristics‚Äîfrom real-time video streaming requiring consistent bandwidth to bulk data transfers tolerating delay‚Äîeffective congestion control ensures fair resource allocation and prevents network collapse. The Leaky Bucket algorithm serves as the foundation for Quality of Service (QoS) implementations, traffic policing in service provider networks, and application-level flow control mechanisms.</p>
                        
                        <div class="technical-details">
                            <h4>Congestion Control Fundamentals</h4>
                            <p><strong>Network Congestion:</strong> Occurs when offered load exceeds network capacity, leading to increased delays, packet loss, and potential network collapse. Effective congestion control prevents these conditions through proactive traffic management.</p>
                            
                            <p><strong>Traffic Characteristics:</strong> Real network traffic exhibits burstiness across multiple timescales, from microsecond packet arrivals to seasonal usage patterns. Traffic shaping algorithms must adapt to this inherent variability.</p>
                            
                            <p><strong>Quality of Service (QoS):</strong> Provides differentiated service levels for different traffic types, ensuring critical applications receive necessary resources while maintaining overall network stability.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Leaky Bucket Algorithm</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/ConjestionControl.png" alt="Leaky Bucket Algorithm">
                            </div>
                            <div class="concept-description">
                                <p><strong>Algorithm Metaphor:</strong> Visualized as a bucket with a small hole at the bottom, where incoming packets fill the bucket and outgoing packets drain at a constant rate. This simple model provides powerful traffic regulation capabilities.</p>
                                
                                <p><strong>Core Components:</strong></p>
                                <ul>
                                    <li><strong>Bucket Capacity (B):</strong> Maximum buffer size, determining burst tolerance</li>
                                    <li><strong>Leak Rate (R):</strong> Constant output rate in packets/bytes per second</li>
                                    <li><strong>Current Level (L):</strong> Current bucket contents, varying between 0 and B</li>
                                    <li><strong>Overflow Policy:</strong> Action taken when bucket exceeds capacity (drop, mark, delay)</li>
                                </ul>
                                
                                <p><strong>Algorithm Operation:</strong></p>
                                <ol>
                                    <li><strong>Packet Arrival:</strong> Check if adding packet exceeds bucket capacity</li>
                                    <li><strong>Admission Control:</strong> If capacity available, add packet to bucket; otherwise apply overflow policy</li>
                                    <li><strong>Continuous Drainage:</strong> Remove packets at constant leak rate R</li>
                                    <li><strong>State Updates:</strong> Update bucket level and timestamps for next iteration</li>
                                </ol>
                                
                                <p><strong>Mathematical Model:</strong></p>
                                <ul>
                                    <li><strong>Bucket Level:</strong> L(t) = max(0, L(t-Œît) + arrivals(Œît) - R√óŒît)</li>
                                    <li><strong>Constraint:</strong> L(t) ‚â§ B (bucket capacity)</li>
                                    <li><strong>Output Rate:</strong> min(R, arrival_rate) when bucket not empty</li>
                                    <li><strong>Burst Accommodation:</strong> Can handle bursts up to B packets at rate > R</li>
                                </ul>
                                
                                <p><strong>Leaky Bucket Variants:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Variant</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Characteristics</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Applications</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Trade-offs</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Classic Leaky Bucket</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Constant output rate</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Voice/video traffic</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Delay vs. smoothing</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Token Bucket</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Variable output rate</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Data applications</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Complexity vs. flexibility</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Dual Token Bucket</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Committed/excess rates</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Service provider networks</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">SLA enforcement complexity</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Sliding Window</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Time-based rate limiting</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">API rate limiting</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Memory vs. accuracy</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Performance Analysis:</strong></p>
                                <ul>
                                    <li><strong>Burst Handling:</strong> Accommodates bursts up to bucket capacity without packet loss</li>
                                    <li><strong>Smoothing Effect:</strong> Converts bursty input into smooth output at leak rate</li>
                                    <li><strong>Delay Introduction:</strong> Average delay = bucket_level / leak_rate</li>
                                    <li><strong>Buffer Requirements:</strong> Memory usage scales linearly with bucket capacity</li>
                                </ul>
                                
                                <p><strong>Implementation Considerations:</strong></p>
                                <ul>
                                    <li><strong>Timer Precision:</strong> High-resolution timers ensure accurate rate control</li>
                                    <li><strong>Overflow Policies:</strong> Drop tail, random drop, priority-based selection</li>
                                    <li><strong>Multi-queue Support:</strong> Per-flow or per-class bucket implementations</li>
                                    <li><strong>Hardware Acceleration:</strong> FPGA/ASIC implementations for line-rate processing</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Token Bucket vs. Leaky Bucket</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Token Bucket Algorithm:</strong> Allows variable output rates by accumulating tokens at a constant rate. Packets can only be transmitted when sufficient tokens are available, providing more flexibility than the classic leaky bucket.</p>
                                
                                <p><strong>Token Bucket Operation:</strong></p>
                                <ol>
                                    <li><strong>Token Generation:</strong> Tokens added to bucket at constant rate R</li>
                                    <li><strong>Packet Transmission:</strong> Each packet requires tokens equal to its size</li>
                                    <li><strong>Token Consumption:</strong> Remove required tokens when transmitting packet</li>
                                    <li><strong>Burst Transmission:</strong> Multiple packets can be sent if tokens available</li>
                                </ol>
                                
                                <p><strong>Key Differences:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Aspect</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Leaky Bucket</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Token Bucket</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Impact</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Output Rate</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Constant</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Variable</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Traffic smoothing vs. efficiency</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Burst Handling</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Buffers bursts</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Allows bursts</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Delay vs. immediate transmission</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Queue Discipline</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">FIFO buffer</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Token counter</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Memory usage patterns</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Application Fit</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Real-time traffic</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Bursty data traffic</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Use case optimization</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Advanced Token Bucket Configurations:</strong></p>
                                <ul>
                                    <li><strong>Hierarchical Token Buckets:</strong> Multiple bucket levels for complex traffic policies</li>
                                    <li><strong>Class-Based Queuing (CBQ):</strong> Per-class token buckets with borrowing mechanisms</li>
                                    <li><strong>Weighted Fair Queuing (WFQ):</strong> Token distribution based on traffic weights</li>
                                    <li><strong>Deficit Round Robin (DRR):</strong> Quantum-based token allocation for fairness</li>
                                </ul>
                                
                                <p><strong>Practical Implementation Guidelines:</strong></p>
                                <ul>
                                    <li><strong>Bucket Sizing:</strong> Balance burst accommodation with memory usage</li>
                                    <li><strong>Rate Calculations:</strong> Account for packet headers and protocol overhead</li>
                                    <li><strong>Clock Granularity:</strong> Use high-resolution timers for accurate token generation</li>
                                    <li><strong>Overflow Handling:</strong> Implement appropriate policies for excess traffic</li>
                                </ul>
                                
                                <p><strong>Performance Metrics:</strong></p>
                                <ul>
                                    <li><strong>Throughput:</strong> Effective data rate under various traffic patterns</li>
                                    <li><strong>Latency:</strong> Average packet delay through shaping mechanism</li>
                                    <li><strong>Jitter:</strong> Variation in packet inter-arrival times</li>
                                    <li><strong>Loss Rate:</strong> Percentage of packets dropped due to overflow</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Quality of Service (QoS) Applications</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/FrameSortingTechnique.png" alt="QoS Implementation">
                            </div>
                            <div class="concept-description">
                                <p><strong>Integrated Services (IntServ):</strong> Provides per-flow QoS guarantees using resource reservation protocols like RSVP. Each flow receives dedicated bandwidth and buffer resources based on application requirements.</p>
                                
                                <p><strong>Differentiated Services (DiffServ):</strong></p>
                                <ul>
                                    <li><strong>Traffic Classification:</strong> Mark packets with DSCP (Differentiated Services Code Point) values</li>
                                    <li><strong>Per-Hop Behaviors (PHB):</strong> Define treatment at each network node</li>
                                    <li><strong>Expedited Forwarding (EF):</strong> Low-latency, low-jitter service for real-time traffic</li>
                                    <li><strong>Assured Forwarding (AF):</strong> Multiple service classes with drop precedence levels</li>
                                </ul>
                                
                                <p><strong>Traffic Engineering with Leaky Buckets:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Service Class</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Bucket Size</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Leak Rate</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Application Examples</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Premium (EF)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Small (1-2 MTU)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">High, constant</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">VoIP, video conferencing</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Business (AF3)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Medium (10-50 MTU)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Guaranteed minimum</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Mission-critical data</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Standard (AF1)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Large (100+ MTU)</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Best effort</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Web browsing, email</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Bulk (BE)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Very large</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Low priority</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">File transfers, backups</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Service Level Agreements (SLAs):</strong></p>
                                <ul>
                                    <li><strong>Committed Information Rate (CIR):</strong> Guaranteed minimum bandwidth</li>
                                    <li><strong>Excess Information Rate (EIR):</strong> Additional burst capacity when available</li>
                                    <li><strong>Committed Burst Size (CBS):</strong> Maximum burst at CIR without penalty</li>
                                    <li><strong>Excess Burst Size (EBS):</strong> Additional burst capacity marked as discard-eligible</li>
                                </ul>
                                
                                <p><strong>Modern QoS Implementations:</strong></p>
                                <ul>
                                    <li><strong>Software-Defined Networking (SDN):</strong> Centralized QoS policy management</li>
                                    <li><strong>Network Function Virtualization (NFV):</strong> Virtualized traffic shaping functions</li>
                                    <li><strong>Intent-Based Networking (IBN):</strong> Automated QoS configuration based on business intent</li>
                                    <li><strong>Machine Learning QoS:</strong> Adaptive traffic shaping based on network conditions</li>
                                </ul>
                                
                                <p><strong>Measurement and Monitoring:</strong></p>
                                <ul>
                                    <li><strong>Flow Monitoring:</strong> Real-time traffic analysis using tools like sFlow, NetFlow</li>
                                    <li><strong>Performance Metrics:</strong> Latency, jitter, packet loss, throughput measurements</li>
                                    <li><strong>SLA Compliance:</strong> Automated reporting and alerting for service violations</li>
                                    <li><strong>Optimization:</strong> Continuous tuning based on traffic patterns and requirements</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Algorithm Mastery:</strong> Understand leaky bucket and token bucket algorithms, their differences, and appropriate applications</li>
                            <li><strong>Traffic Analysis:</strong> Analyze traffic patterns, burstiness characteristics, and shaping effectiveness</li>
                            <li><strong>QoS Implementation:</strong> Design and configure Quality of Service policies using traffic shaping mechanisms</li>
                            <li><strong>Performance Optimization:</strong> Optimize bucket parameters for specific traffic requirements and network conditions</li>
                            <li><strong>Service Design:</strong> Implement service level agreements and multi-class traffic management systems</li>
                            <li><strong>Troubleshooting Skills:</strong> Diagnose congestion issues and tune traffic shaping parameters for optimal performance</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Traffic Management</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üåê Internet Service Providers</h4>
                                <p>ISPs use hierarchical token buckets for subscriber bandwidth management, implementing committed and excess rates for different service tiers while ensuring fair resource allocation.</p>
                            </div>
                            <div class="application-item">
                                <h4>‚òÅÔ∏è Cloud Service Platforms</h4>
                                <p>Cloud providers implement rate limiting at API gateways, storage systems, and compute instances using leaky bucket algorithms to prevent abuse and ensure service stability.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì± Mobile Network Operators</h4>
                                <p>5G networks use advanced traffic shaping for network slicing, providing guaranteed resources for ultra-reliable low-latency communications (URLLC) and enhanced mobile broadband (eMBB).</p>
                            </div>
                            <div class="application-item">
                                <h4>üè¢ Enterprise Networks</h4>
                                <p>Enterprise WANs employ QoS with traffic shaping to prioritize business-critical applications over recreational traffic, optimizing limited bandwidth resources.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="implementation-guide">
                        <h3>Implementation Guide & Simulation Examples</h3>
                        
                        <div class="simulation-guide">
                            <h4>Network Simulator Implementation</h4>
                            <div class="guide-content">
                                <p><strong>NS-3 Traffic Shaping Simulation:</strong></p>
                                <ol>
                                    <li>Create network topology with sender, router, and receiver nodes</li>
                                    <li>Install leaky bucket traffic shaper at router interface</li>
                                    <li>Generate bursty traffic using OnOff applications</li>
                                    <li>Monitor queue occupancy and packet drop rates</li>
                                    <li>Analyze traffic smoothing effectiveness</li>
                                </ol>
                                
                                <p><strong>Performance Metrics to Collect:</strong></p>
                                <ul>
                                    <li>Average queue length and maximum queue occupancy</li>
                                    <li>Packet drop ratio under various traffic loads</li>
                                    <li>Output traffic smoothness (variance analysis)</li>
                                    <li>End-to-end delay and jitter measurements</li>
                                </ul>
                                
                                <p><strong>Algorithm Concepts to Implement:</strong></p>
                                <ul>
                                    <li><strong>Leaky Bucket:</strong> Constant rate output with burst buffering</li>
                                    <li><strong>Token Bucket:</strong> Variable rate output with token-based control</li>
                                    <li><strong>Rate Limiting:</strong> Traffic policing and shaping mechanisms</li>
                                    <li><strong>Queue Management:</strong> Buffer overflow handling and drop policies</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 9: Frame Sorting Technique -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 9: Frame Sorting Technique (Buffers)</h2>
                    <div class="week-badge">Buffer Management</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Frame sorting and buffer management address one of the fundamental challenges in packet-switched networks: maintaining data integrity and order when packets traverse different paths and experience varying delays. In modern networks where packets may arrive out of sequence due to load balancing, routing changes, or network congestion, sophisticated buffer management techniques ensure applications receive data in the correct order while optimizing memory usage and minimizing latency.</p>
                        
                        <p>This challenge becomes increasingly complex in high-speed networks where buffer memory is expensive and latency requirements are stringent. From TCP's sophisticated receive windows to video streaming protocols that handle frame dependencies, understanding buffer management principles is essential for designing robust network applications and protocols that can handle the inherent unpredictability of packet-switched networks.</p>
                        
                        <div class="technical-details">
                            <h4>Packet Reordering Fundamentals</h4>
                            <p><strong>Reordering Causes:</strong> Modern networks with Equal-Cost Multi-Path (ECMP) routing, load balancers, and parallel processing can cause packets to arrive out of order, requiring sophisticated buffering strategies.</p>
                            
                            <p><strong>Ordering Requirements:</strong> Different applications have varying tolerance for reordering - while DNS queries can handle completely unordered responses, video streaming requires frame-level ordering for proper decoding.</p>
                            
                            <p><strong>Memory vs. Latency Trade-offs:</strong> Larger buffers can accommodate more reordering but increase latency and memory costs, requiring careful optimization for specific application requirements.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Buffer Management Algorithms</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Sliding Window Buffers:</strong> The foundation of reliable data transport, maintaining a contiguous range of sequence numbers with configurable window sizes to balance memory usage with reordering tolerance.</p>
                                
                                <p><strong>Buffer Organization Strategies:</strong></p>
                                <ul>
                                    <li><strong>Linear Buffer:</strong> Simple array-based storage with O(n) search complexity</li>
                                    <li><strong>Linked List:</strong> Dynamic allocation with O(n) insertion and search</li>
                                    <li><strong>Priority Queue:</strong> Heap-based structure for O(log n) operations</li>
                                    <li><strong>Hash Table:</strong> O(1) average access time for random sequence numbers</li>
                                    <li><strong>Ring Buffer:</strong> Circular buffer for efficient sliding window implementation</li>
                                </ul>
                                
                                <p><strong>Reordering Detection and Handling:</strong></p>
                                <ol>
                                    <li><strong>Sequence Number Analysis:</strong> Compare incoming packet sequence with expected next sequence</li>
                                    <li><strong>Gap Detection:</strong> Identify missing sequences and maintain gap lists</li>
                                    <li><strong>Duplicate Handling:</strong> Detect and discard duplicate packets efficiently</li>
                                    <li><strong>Timeout Management:</strong> Release buffers after maximum reordering delay</li>
                                    <li><strong>Delivery Notification:</strong> Signal application when ordered data is available</li>
                                </ol>
                                
                                <p><strong>TCP Receive Buffer Implementation:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Component</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Function</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Data Structure</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Complexity</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Receive Window</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Advertise buffer space</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Ring buffer</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(1) access</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Out-of-Order Queue</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Store reordered segments</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Skiplist/RB-tree</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(log n)</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>SACK Blocks</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Report received ranges</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Interval tree</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(log n)</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Reassembly Queue</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Merge overlapping segments</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Linked list</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">O(n) merge</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Memory Management Optimizations:</strong></p>
                                <ul>
                                    <li><strong>Zero-Copy Buffers:</strong> Avoid data copying between kernel and user space</li>
                                    <li><strong>Buffer Pools:</strong> Pre-allocated memory pools for efficient allocation</li>
                                    <li><strong>Adaptive Sizing:</strong> Dynamic buffer size adjustment based on network conditions</li>
                                    <li><strong>Memory Mapping:</strong> Use virtual memory techniques for large buffers</li>
                                    <li><strong>NUMA Awareness:</strong> Optimize memory allocation for multi-socket systems</li>
                                </ul>
                                
                                <p><strong>Performance Characteristics:</strong></p>
                                <ul>
                                    <li><strong>Buffer Occupancy:</strong> Monitor buffer utilization to detect congestion</li>
                                    <li><strong>Reordering Metrics:</strong> Track reordering frequency and magnitude</li>
                                    <li><strong>Latency Analysis:</strong> Measure head-of-line blocking delays</li>
                                    <li><strong>Memory Efficiency:</strong> Bytes allocated vs. useful payload ratio</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Sequence Number Management</h4>
                                <span class="difficulty-badge medium">Intermediate</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Sequence Space Management:</strong> Efficient handling of finite sequence number spaces requires careful consideration of wraparound, comparison operations, and window positioning to maintain correctness across connection lifetimes.</p>
                                
                                <p><strong>Sequence Number Arithmetic:</strong></p>
                                <ul>
                                    <li><strong>Modular Arithmetic:</strong> TCP uses 32-bit sequence numbers with modular wraparound</li>
                                    <li><strong>Comparison Operations:</strong> Special algorithms for comparing sequence numbers across wraparound boundary</li>
                                    <li><strong>Window Validation:</strong> Ensure received packets fall within acceptable window ranges</li>
                                    <li><strong>Initial Sequence Numbers (ISN):</strong> Cryptographically secure random generation prevents attacks</li>
                                </ul>
                                
                                <p><strong>Gap Management Algorithms:</strong></p>
                                <ol>
                                    <li><strong>Gap List Maintenance:</strong> Track missing sequence ranges efficiently</li>
                                    <li><strong>Coalescing Operations:</strong> Merge adjacent received segments</li>
                                    <li><strong>Overlap Detection:</strong> Handle partially overlapping segments correctly</li>
                                    <li><strong>Timeout Handling:</strong> Remove stale gaps after timeout periods</li>
                                </ol>
                                
                                <p><strong>Advanced Techniques:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Technique</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Description</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Benefits</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Complexity</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>SACK (Selective ACK)</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Report non-contiguous received blocks</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Faster recovery, less retransmission</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Medium</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>D-SACK</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Report duplicate segments</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Distinguish loss from reordering</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Low</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>F-RTO</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Forward RTO recovery</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Distinguish loss from reordering</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Medium</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>RACK</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Recent ACK based loss detection</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Time-based loss detection</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">High</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Reordering Tolerance Strategies:</strong></p>
                                <ul>
                                    <li><strong>Adaptive Thresholds:</strong> Dynamically adjust reordering tolerance based on network conditions</li>
                                    <li><strong>Time-based Detection:</strong> Use time intervals rather than packet counts for loss detection</li>
                                    <li><strong>Path Diversity Handling:</strong> Account for multiple paths with different characteristics</li>
                                    <li><strong>Application Hints:</strong> Use application-level information to optimize buffering</li>
                                </ul>
                                
                                <p><strong>Implementation Best Practices:</strong></p>
                                <ul>
                                    <li><strong>Efficient Data Structures:</strong> Use appropriate data structures for sequence operations</li>
                                    <li><strong>Memory Bounds:</strong> Implement strict memory limits to prevent DoS attacks</li>
                                    <li><strong>Fast Path Optimization:</strong> Optimize for in-order delivery common case</li>
                                    <li><strong>Instrumentation:</strong> Add metrics and logging for debugging and optimization</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Application-Specific Buffer Strategies</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Multimedia Streaming Buffers:</strong> Video and audio streaming applications require specialized buffering strategies that consider frame dependencies, decoding requirements, and real-time constraints while maintaining smooth playback experience.</p>
                                
                                <p><strong>Video Streaming Buffer Management:</strong></p>
                                <ul>
                                    <li><strong>Frame Types:</strong> I-frames (intra), P-frames (predicted), B-frames (bi-directional) have different importance</li>
                                    <li><strong>GOP Structure:</strong> Group of Pictures determines frame dependencies and buffer requirements</li>
                                    <li><strong>Adaptive Bitrate:</strong> Dynamic quality adjustment based on buffer levels and network conditions</li>
                                    <li><strong>Jitter Buffer:</strong> Compensate for network delay variation while minimizing latency</li>
                                </ul>
                                
                                <p><strong>Real-time Communication Buffers:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Application</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Buffer Size</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Latency Target</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Loss Tolerance</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>VoIP</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">20-100ms</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><150ms end-to-end</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">1-3% acceptable</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Video Conferencing</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">100-300ms</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><200ms interactive</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Error concealment</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Live Streaming</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">2-10 seconds</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Low latency preferred</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Retransmission possible</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Gaming</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Minimal</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><50ms critical</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Very low tolerance</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Database and File System Buffers:</strong></p>
                                <ul>
                                    <li><strong>Write-Through Caching:</strong> Immediate disk writes with memory caching for reads</li>
                                    <li><strong>Write-Back Caching:</strong> Delayed disk writes with periodic flushing</li>
                                    <li><strong>Read-Ahead Buffers:</strong> Predictive reading based on access patterns</li>
                                    <li><strong>Transaction Logs:</strong> Ordered write buffers for ACID compliance</li>
                                </ul>
                                
                                <p><strong>Buffer Sizing Algorithms:</strong></p>
                                <ul>
                                    <li><strong>Bandwidth-Delay Product:</strong> BDP = bandwidth √ó round-trip time for optimal sizing</li>
                                    <li><strong>Additive Increase:</strong> Gradually increase buffer size during stable conditions</li>
                                    <li><strong>Multiplicative Decrease:</strong> Rapidly reduce buffer size during congestion</li>
                                    <li><strong>Machine Learning:</strong> Use ML algorithms to predict optimal buffer sizes</li>
                                </ul>
                                
                                <p><strong>Modern Buffer Management Trends:</strong></p>
                                <ul>
                                    <li><strong>Edge Computing:</strong> Distributed buffering closer to end users</li>
                                    <li><strong>RDMA Optimization:</strong> Zero-copy networking with remote direct memory access</li>
                                    <li><strong>NVMe Storage:</strong> Ultra-low latency storage buffers</li>
                                    <li><strong>Container Orchestration:</strong> Dynamic buffer allocation in Kubernetes environments</li>
                                </ul>
                                
                                <p><strong>Security Considerations:</strong></p>
                                <ul>
                                    <li><strong>Buffer Overflow Protection:</strong> Bounds checking and memory safety</li>
                                    <li><strong>DoS Mitigation:</strong> Rate limiting and resource quotas</li>
                                    <li><strong>Data Integrity:</strong> Checksums and error detection in buffers</li>
                                    <li><strong>Information Leakage:</strong> Secure buffer clearing and memory protection</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Buffer Architecture:</strong> Design efficient buffer management systems for different application requirements and network conditions</li>
                            <li><strong>Sequence Handling:</strong> Master sequence number arithmetic, gap management, and reordering detection algorithms</li>
                            <li><strong>Memory Optimization:</strong> Implement memory-efficient data structures and allocation strategies for high-performance buffering</li>
                            <li><strong>Protocol Implementation:</strong> Understand TCP, UDP, and application-specific buffering mechanisms and their trade-offs</li>
                            <li><strong>Performance Analysis:</strong> Measure and optimize buffer performance metrics including latency, throughput, and memory usage</li>
                            <li><strong>Application Integration:</strong> Adapt buffer strategies for multimedia, real-time, and data-intensive applications</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Buffer Management</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üì∫ Streaming Platforms</h4>
                                <p>Netflix, YouTube, and other streaming services use adaptive buffering algorithms that adjust buffer sizes based on device capabilities, network conditions, and content characteristics to provide smooth playback.</p>
                            </div>
                            <div class="application-item">
                                <h4>üéÆ Online Gaming</h4>
                                <p>Multiplayer games implement client-side prediction with rollback buffers to maintain responsiveness while handling network latency and packet loss in competitive gaming environments.</p>
                            </div>
                            <div class="application-item">
                                <h4>üíæ High-Performance Storage</h4>
                                <p>Modern SSDs and distributed storage systems use multi-tier buffering with write coalescing, read-ahead, and intelligent caching to maximize throughput and minimize latency.</p>
                            </div>
                            <div class="application-item">
                                <h4>‚òÅÔ∏è Edge Computing</h4>
                                <p>Content delivery networks (CDNs) deploy edge caches with intelligent buffer management to reduce origin server load and improve user experience globally.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="implementation-guide">
                        <h3>Implementation Guide & Buffer Analysis</h3>
                        
                        <div class="simulation-guide">
                            <h4>Buffer Management Simulation</h4>
                            <div class="guide-content">
                                <p><strong>NS-3 Buffer Analysis Simulation:</strong></p>
                                <ol>
                                    <li>Create network with multiple paths causing packet reordering</li>
                                    <li>Implement custom application with receive buffer</li>
                                    <li>Generate traffic with varying packet sizes and timing</li>
                                    <li>Monitor buffer occupancy and reordering statistics</li>
                                    <li>Measure application-level throughput and latency</li>
                                </ol>
                                
                                <p><strong>Key Simulation Parameters:</strong></p>
                                <ul>
                                    <li>Buffer sizes: 64KB, 128KB, 256KB, 512KB</li>
                                    <li>Reordering probability: 1%, 5%, 10%, 20%</li>
                                    <li>Maximum reordering distance: 3, 10, 50 packets</li>
                                    <li>Traffic patterns: CBR, Poisson, bursty</li>
                                </ul>
                                
                                <p><strong>Performance Metrics:</strong></p>
                                <ul>
                                    <li>Buffer utilization percentage over time</li>
                                    <li>Average and maximum reordering delay</li>
                                    <li>Memory efficiency (useful data vs. overhead)</li>
                                    <li>Application goodput vs. network throughput</li>
                                </ul>
                                
                                <p><strong>Buffer Management Concepts:</strong></p>
                                <ul>
                                    <li><strong>Sliding Window:</strong> Maintain contiguous sequence ranges</li>
                                    <li><strong>Sequence Handling:</strong> Gap detection and duplicate removal</li>
                                    <li><strong>Memory Management:</strong> Efficient allocation and deallocation</li>
                                    <li><strong>Flow Control:</strong> Back-pressure mechanisms</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Week 10: Packet Capture and Analysis -->
            <section class="week-section">
                <div class="week-header">
                    <h2 class="week-title">Week 10: Packet Capture and Analysis (Wireshark Concept)</h2>
                    <div class="week-badge">Network Analysis</div>
                </div>
                
                <div class="week-content">
                    <div class="concept-overview">
                        <h3>Overview</h3>
                        <p>Packet capture and analysis represents the ultimate networking detective work, providing unprecedented visibility into network behavior, protocol interactions, and communication patterns. Modern network analysis tools like Wireshark have revolutionized network troubleshooting, security analysis, and performance optimization by enabling engineers to examine individual packets, decode complex protocols, and correlate traffic patterns across multiple network layers.</p>
                        
                        <p>In today's complex networking environments with virtualization, cloud computing, and microservices architectures, packet analysis skills are indispensable for identifying performance bottlenecks, security threats, and protocol violations. From debugging intermittent connectivity issues to conducting forensic analysis of security incidents, packet capture provides the ground truth about network behavior that cannot be obtained through any other means.</p>
                        
                        <div class="technical-details">
                            <h4>Packet Capture Fundamentals</h4>
                            <p><strong>Network Taps and Port Mirroring:</strong> Modern packet capture requires strategic placement of capture points using network TAPs, switch port mirroring (SPAN), or software-based capture agents to ensure comprehensive traffic visibility.</p>
                            
                            <p><strong>Promiscuous Mode:</strong> Network interfaces operating in promiscuous mode can capture all packets on the network segment, not just those destined for the local host, enabling comprehensive traffic analysis.</p>
                            
                            <p><strong>Capture Filters vs. Display Filters:</strong> Capture filters reduce the volume of captured data at the source, while display filters enable post-capture analysis of specific traffic patterns without affecting the underlying capture file.</p>
                        </div>
                    </div>

                    <div class="concepts-grid">
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Wireshark Architecture & Capabilities</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-image">
                                <img src="assets/packetCapture.png" alt="Wireshark Analysis">
                            </div>
                            <div class="concept-description">
                                <p><strong>Wireshark Framework:</strong> Built on the powerful libpcap (Unix) and WinPcap/Npcap (Windows) libraries, Wireshark provides a comprehensive protocol analysis platform supporting over 3000 network protocols with sophisticated dissection and analysis capabilities.</p>
                                
                                <p><strong>Core Components:</strong></p>
                                <ul>
                                    <li><strong>Capture Engine:</strong> Real-time packet capture with configurable filters and buffer management</li>
                                    <li><strong>Protocol Dissectors:</strong> Modular protocol decoders for parsing and interpreting packet contents</li>
                                    <li><strong>Display Engine:</strong> Advanced filtering, searching, and visualization capabilities</li>
                                    <li><strong>Analysis Tools:</strong> Statistical analysis, flow tracking, and expert system diagnostics</li>
                                </ul>
                                
                                <p><strong>Advanced Wireshark Features:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Feature</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Purpose</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Use Cases</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Benefits</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Follow TCP Stream</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Reconstruct application data</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">HTTP analysis, malware investigation</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Complete conversation view</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Expert System</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Automated problem detection</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Performance issues, errors</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Guided troubleshooting</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Statistics & Graphs</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Traffic visualization</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Capacity planning, trend analysis</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Pattern recognition</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Protocol Hierarchies</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Protocol distribution analysis</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Network profiling, optimization</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Traffic composition insights</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Display Filter Language:</strong></p>
                                <ul>
                                    <li><strong>Protocol Filters:</strong> tcp, udp, http, dns for protocol-specific analysis</li>
                                    <li><strong>Field Filters:</strong> ip.addr, tcp.port, http.host for specific field matching</li>
                                    <li><strong>Logical Operators:</strong> and, or, not for complex filter combinations</li>
                                    <li><strong>Comparison Operators:</strong> ==, !=, >, <, contains, matches for value testing</li>
                                    <li><strong>Functions:</strong> upper(), lower(), len() for field manipulation</li>
                                </ul>
                                
                                <p><strong>Performance Optimization:</strong></p>
                                <ul>
                                    <li><strong>Ring Buffers:</strong> Configure appropriate buffer sizes to prevent packet loss</li>
                                    <li><strong>Capture Filters:</strong> Use BPF filters to reduce capture overhead</li>
                                    <li><strong>File Segmentation:</strong> Split large captures into manageable file sizes</li>
                                    <li><strong>Remote Capture:</strong> Use remote capture capabilities for distributed analysis</li>
                                </ul>
                                
                                <p><strong>Security Considerations:</strong></p>
                                <ul>
                                    <li><strong>Privilege Requirements:</strong> Root/admin access for packet capture operations</li>
                                    <li><strong>Data Protection:</strong> Encrypt capture files containing sensitive information</li>
                                    <li><strong>Legal Compliance:</strong> Ensure packet capture complies with privacy regulations</li>
                                    <li><strong>Network Impact:</strong> Monitor capture overhead on production systems</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Protocol Analysis Techniques</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Layered Protocol Analysis:</strong> Systematic examination of network communications from physical layer framing through application layer protocols, understanding encapsulation, protocol interactions, and layer-specific behaviors.</p>
                                
                                <p><strong>Common Protocol Analysis Patterns:</strong></p>
                                <ol>
                                    <li><strong>TCP Connection Analysis:</strong> Three-way handshake, data transfer, congestion control, and termination phases</li>
                                    <li><strong>HTTP Transaction Analysis:</strong> Request-response pairs, headers, content encoding, and caching behavior</li>
                                    <li><strong>DNS Resolution Tracking:</strong> Query-response patterns, caching, and resolution chains</li>
                                    <li><strong>DHCP Lease Process:</strong> Discover, offer, request, acknowledge sequence analysis</li>
                                </ol>
                                
                                <p><strong>Performance Analysis Techniques:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Metric</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Analysis Method</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Tools/Features</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Insights</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Round Trip Time</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">TCP timestamp analysis</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">TCP Stream Graphs</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Network latency patterns</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Throughput</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Bytes/time analysis</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">IO Graphs, Statistics</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Bandwidth utilization</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Packet Loss</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Sequence gap analysis</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Expert System alerts</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Network reliability issues</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Application Response</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Request-response timing</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Service Response Time</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Application performance</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Security Analysis Techniques:</strong></p>
                                <ul>
                                    <li><strong>Anomaly Detection:</strong> Identify unusual traffic patterns, protocol violations, or suspicious behaviors</li>
                                    <li><strong>Attack Signatures:</strong> Recognize known attack patterns like port scans, DDoS, or malware communications</li>
                                    <li><strong>Encrypted Traffic Analysis:</strong> Analyze metadata, timing, and size patterns in encrypted communications</li>
                                    <li><strong>Lateral Movement Detection:</strong> Track internal network communications for signs of compromise</li>
                                </ul>
                                
                                <p><strong>Troubleshooting Methodologies:</strong></p>
                                <ul>
                                    <li><strong>Top-Down Analysis:</strong> Start with application symptoms and work down through protocol layers</li>
                                    <li><strong>Bottom-Up Analysis:</strong> Begin with physical/link layer issues and work up to applications</li>
                                    <li><strong>Divide and Conquer:</strong> Isolate problems by systematically eliminating possible causes</li>
                                    <li><strong>Comparative Analysis:</strong> Compare problematic traffic with known-good baselines</li>
                                </ul>
                                
                                <p><strong>Advanced Analysis Techniques:</strong></p>
                                <ul>
                                    <li><strong>Flow Analysis:</strong> Track complete conversations and their relationships</li>
                                    <li><strong>Timing Analysis:</strong> Examine inter-packet timing for performance insights</li>
                                    <li><strong>Statistical Analysis:</strong> Apply statistical methods to identify trends and patterns</li>
                                    <li><strong>Behavioral Analysis:</strong> Model normal behavior and detect deviations</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="concept-card">
                            <div class="concept-header">
                                <h4>Modern Network Monitoring & Analysis</h4>
                                <span class="difficulty-badge hard">Advanced</span>
                            </div>
                            <div class="concept-description">
                                <p><strong>Enterprise Network Monitoring:</strong> Modern networks require sophisticated monitoring solutions that combine packet capture with flow analysis, synthetic monitoring, and machine learning-based anomaly detection to provide comprehensive visibility.</p>
                                
                                <p><strong>Flow-Based Analysis:</strong></p>
                                <ul>
                                    <li><strong>NetFlow/sFlow:</strong> Sampled flow records providing scalable traffic visibility</li>
                                    <li><strong>IPFIX:</strong> Internet Protocol Flow Information Export for standardized flow reporting</li>
                                    <li><strong>Flow Aggregation:</strong> Summarize millions of flows into meaningful traffic patterns</li>
                                    <li><strong>Application Recognition:</strong> Deep packet inspection (DPI) for application classification</li>
                                </ul>
                                
                                <p><strong>Cloud and Virtualization Challenges:</strong></p>
                                <table style="width: 100%; margin: 1rem 0; border-collapse: collapse;">
                                    <tr style="background-color: var(--bg-primary);">
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Environment</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Monitoring Challenges</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Solutions</th>
                                        <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Tools</th>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Virtual Networks</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">East-west traffic visibility</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Virtual TAPs, vSwitch monitoring</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">VMware NSX, OVS</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Containers</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Ephemeral workload tracking</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Service mesh monitoring</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Istio, Linkerd, Cilium</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Cloud Networks</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Multi-cloud connectivity</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Cloud-native monitoring</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">AWS VPC Flow Logs, Azure NSG</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Microservices</strong></td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Service dependency mapping</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Distributed tracing</td>
                                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Jaeger, Zipkin, OpenTelemetry</td>
                                    </tr>
                                </table>
                                
                                <p><strong>Machine Learning in Network Analysis:</strong></p>
                                <ul>
                                    <li><strong>Anomaly Detection:</strong> Unsupervised learning to identify unusual traffic patterns</li>
                                    <li><strong>Classification:</strong> Automated application and threat classification</li>
                                    <li><strong>Predictive Analytics:</strong> Forecast network capacity and performance issues</li>
                                    <li><strong>Behavioral Baselining:</strong> Learn normal network behavior patterns</li>
                                </ul>
                                
                                <p><strong>Next-Generation Analysis Tools:</strong></p>
                                <ul>
                                    <li><strong>Packet Brokers:</strong> Intelligent traffic distribution to analysis tools</li>
                                    <li><strong>Edge Analytics:</strong> Real-time analysis at network edge locations</li>
                                    <li><strong>GPU Acceleration:</strong> High-speed pattern matching and analysis</li>
                                    <li><strong>Streaming Analytics:</strong> Real-time processing of high-volume network data</li>
                                </ul>
                                
                                <p><strong>Compliance and Forensics:</strong></p>
                                <ul>
                                    <li><strong>Data Retention:</strong> Long-term storage for compliance and forensic analysis</li>
                                    <li><strong>Chain of Custody:</strong> Secure evidence handling procedures</li>
                                    <li><strong>Privacy Protection:</strong> Data anonymization and access controls</li>
                                    <li><strong>Automated Reporting:</strong> Compliance dashboards and audit trails</li>
                                </ul>
                                
                                <p><strong>Integration with DevOps:</strong></p>
                                <ul>
                                    <li><strong>Infrastructure as Code:</strong> Automated monitoring deployment</li>
                                    <li><strong>CI/CD Integration:</strong> Network testing in deployment pipelines</li>
                                    <li><strong>Observability:</strong> Metrics, logs, and traces for comprehensive visibility</li>
                                    <li><strong>Chaos Engineering:</strong> Network resilience testing and validation</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="learning-objectives">
                        <h3>Learning Objectives</h3>
                        <ul>
                            <li><strong>Tool Mastery:</strong> Master Wireshark and other packet analysis tools for comprehensive network investigation</li>
                            <li><strong>Protocol Expertise:</strong> Develop deep understanding of network protocols and their interactions across all layers</li>
                            <li><strong>Analysis Techniques:</strong> Learn systematic approaches to performance analysis, security investigation, and troubleshooting</li>
                            <li><strong>Modern Monitoring:</strong> Understand contemporary network monitoring challenges in cloud, virtualized, and containerized environments</li>
                            <li><strong>Security Analysis:</strong> Apply packet analysis for cybersecurity investigations and threat hunting</li>
                            <li><strong>Automation Skills:</strong> Integrate packet analysis with automation tools and machine learning for scalable network operations</li>
                        </ul>
                    </div>
                    
                    <div class="practical-applications">
                        <h3>Industry Applications & Modern Network Analysis</h3>
                        <div class="application-grid">
                            <div class="application-item">
                                <h4>üîí Cybersecurity Operations</h4>
                                <p>Security operations centers (SOCs) use advanced packet analysis for threat hunting, incident response, and forensic investigations, combining signature-based detection with behavioral analysis.</p>
                            </div>
                            <div class="application-item">
                                <h4>‚òÅÔ∏è Cloud Network Operations</h4>
                                <p>Cloud providers implement distributed packet capture and analysis systems for customer network troubleshooting, capacity planning, and service assurance across global infrastructure.</p>
                            </div>
                            <div class="application-item">
                                <h4>üè¢ Enterprise IT Operations</h4>
                                <p>Large enterprises deploy network monitoring solutions combining packet capture with flow analysis for application performance monitoring, capacity planning, and user experience optimization.</p>
                            </div>
                            <div class="application-item">
                                <h4>üì° Service Provider Networks</h4>
                                <p>Telecommunications companies use high-speed packet analysis for service assurance, billing verification, and regulatory compliance in carrier-grade networks supporting millions of customers.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="implementation-guide">
                        <h3>Implementation Guide & Wireshark Lab Exercises</h3>
                        
                        <div class="lab-section">
                            <h4>Lab Exercise 1: Basic Packet Capture</h4>
                            <div class="lab-content">
                                <p><strong>Objective:</strong> Learn fundamental packet capture and filtering techniques</p>
                                <div class="exercise-steps">
                                    <ol>
                                        <li><strong>Setup:</strong> Install Wireshark and configure network interface</li>
                                        <li><strong>Capture:</strong> Start packet capture on active network interface</li>
                                        <li><strong>Generate Traffic:</strong> Browse websites, send emails, download files</li>
                                        <li><strong>Analysis:</strong> Apply display filters to isolate specific protocols</li>
                                        <li><strong>Documentation:</strong> Export statistics and create analysis report</li>
                                    </ol>
                                </div>
                                
                                <div class="filter-examples">
                                    <h5>Essential Wireshark Display Filters:</h5>
                                    <div class="filter-list">
                                        <p><code>tcp.port == 80</code> - HTTP traffic only</p>
                                        <p><code>ip.addr == 192.168.1.1</code> - Traffic to/from specific IP</p>
                                        <p><code>tcp.flags.syn == 1</code> - TCP SYN packets</p>
                                        <p><code>http.request.method == "GET"</code> - HTTP GET requests</p>
                                        <p><code>tcp.analysis.retransmission</code> - TCP retransmissions</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lab-section">
                            <h4>Lab Exercise 2: Protocol Analysis</h4>
                            <div class="lab-content">
                                <p><strong>Objective:</strong> Deep dive into TCP connection analysis</p>
                                <div class="analysis-guide">
                                    <h5>TCP Connection Analysis Steps:</h5>
                                    <ol>
                                        <li><strong>Connection Establishment:</strong> Identify three-way handshake packets</li>
                                        <li><strong>Data Transfer:</strong> Analyze sequence numbers and acknowledgments</li>
                                        <li><strong>Window Scaling:</strong> Monitor receive window advertisements</li>
                                        <li><strong>Congestion Control:</strong> Observe slow start and congestion avoidance</li>
                                        <li><strong>Connection Termination:</strong> Follow four-way close sequence</li>
                                    </ol>
                                </div>
                                
                                <div class="metrics-collection">
                                    <h5>Key Metrics to Measure:</h5>
                                    <ul>
                                        <li>Round-trip time (RTT) calculation</li>
                                        <li>Throughput and bandwidth utilization</li>
                                        <li>Packet loss detection and recovery</li>
                                        <li>Window size dynamics</li>
                                        <li>Application response times</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lab-section">
                            <h4>Lab Exercise 3: Network Troubleshooting</h4>
                            <div class="lab-content">
                                <p><strong>Scenario:</strong> Investigate slow web browsing performance</p>
                                <div class="troubleshooting-methodology">
                                    <h5>Systematic Troubleshooting Approach:</h5>
                                    <ol>
                                        <li><strong>Baseline Capture:</strong> Capture normal vs. problematic traffic</li>
                                        <li><strong>Protocol Distribution:</strong> Analyze traffic composition</li>
                                        <li><strong>Response Time Analysis:</strong> Measure application response times</li>
                                        <li><strong>Error Detection:</strong> Use Expert System to identify issues</li>
                                        <li><strong>Root Cause Analysis:</strong> Correlate symptoms with network behavior</li>
                                    </ol>
                                </div>
                                
                                <div class="common-issues">
                                    <h5>Common Network Issues to Identify:</h5>
                                    <ul>
                                        <li><strong>High Latency:</strong> Excessive round-trip times</li>
                                        <li><strong>Packet Loss:</strong> Retransmissions and timeouts</li>
                                        <li><strong>Congestion:</strong> Full queues and dropped packets</li>
                                        <li><strong>Routing Issues:</strong> Suboptimal path selection</li>
                                        <li><strong>DNS Problems:</strong> Slow name resolution</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div class="automation-section">
                            <h4>Automated Analysis Concepts</h4>
                            <div class="guide-content">
                                <p><strong>Command-Line Analysis Tools:</strong></p>
                                <ul>
                                    <li><strong>tshark:</strong> Command-line version of Wireshark for batch processing</li>
                                    <li><strong>tcpdump:</strong> Lightweight packet capture utility</li>
                                    <li><strong>netstat:</strong> Network connection and routing table information</li>
                                    <li><strong>ss:</strong> Modern replacement for netstat with enhanced features</li>
                                </ul>
                                
                                <p><strong>Analysis Capabilities:</strong></p>
                                <ul>
                                    <li>Extract HTTP response times and performance metrics</li>
                                    <li>Generate protocol hierarchy statistics</li>
                                    <li>Export conversation and endpoint statistics</li>
                                    <li>Create time-series data for traffic analysis</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="simulation-integration">
                            <h4>Integration with Network Simulation</h4>
                            <div class="guide-content">
                                <p><strong>NS-3 Packet Capture Integration:</strong></p>
                                <ul>
                                    <li>Enable pcap tracing in NS-3 simulations</li>
                                    <li>Import simulation traces into Wireshark</li>
                                    <li>Compare simulated vs. real network behavior</li>
                                    <li>Validate protocol implementations</li>
                                    <li>Debug simulation models and scenarios</li>
                                </ul>
                                
                                <p><strong>Lab Report Requirements:</strong></p>
                                <ol>
                                    <li>Network topology diagram and configuration</li>
                                    <li>Packet capture methodology and filters used</li>
                                    <li>Statistical analysis of captured traffic</li>
                                    <li>Performance metrics and observations</li>
                                    <li>Troubleshooting findings and recommendations</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script src="script.js"></script>
</body>
</html>
